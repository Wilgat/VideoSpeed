#!/bin/sh
# -*- coding: utf-8 -*-
##! 0<0# : ^
##! """
##! @echo off
##! SET F="C:\\Users\\%USERNAME%\\AppData\\Local\\Microsoft\\WindowsApps\\python.exe"
##! if exist %F% ( del /s %F% >nul 2>&1 )
##! SET G="C:\\Users\\%USERNAME%\\AppData\\Local\\Microsoft\\WindowsApps\\python3.exe"
##! if exist %G% ( del /s %G% >nul 2>&1 )
##! FOR /F "tokens=*" %%g IN ('where python.exe') do (SET VAR=%%g)
##! if exist %VAR% (
##!     python "%~f0" %*
##!     exit /b 0
##! )
##! FOR /F "tokens=*" %%g IN ('where python3.exe') do (SET VAR=%%g)
##! if exist %VAR% ( python3 "%~f0" %* )
##! exit /b 0
##! """
""":"
if [ -f /usr/bin/sw_vers ]; then WHICH='which';elif [ -f /usr/bin/which ]; then WHICH='/usr/bin/which';elif [ -f /bin/which ]; then WHICH='/bin/which';elif [ -f "C:\\Windows\\System32\\where.exe" ]; then WHICH="C:\\Windows\\System32\\where.exe";fi; if [ ! -z $WHICH ]; then _PY_=$($WHICH python3);if [ -z $_PY_ ]; then _PY_=$($WHICH python2); if [ -z $_PY_ ]; then _PY_=$($WHICH pypy3); if [ -z $_PY_ ]; then _PY_=$($WHICH pypy); if [ -z $_PY_ ]; then _PY_=$($WHICH python); if [ -z $_PY_ ]; then echo 'No Python Found'; fi; fi; fi; fi; fi; if [ ! -z "$_PY_" ]; then WINPTY=$($WHICH winpty.exe 2>/dev/null);if [ ! -z "$WINPTY" ]; then PY_EXE=$($WHICH python.exe 2>/dev/null);if [ ! -z "$PY_EXE" ]; then exec "$WINPTY" "$PY_EXE" "$0" "$@";exit 0;fi;else exec $_PY_ "$0" "$@";exit 0;fi;fi;fi;if [  -f /usr/bin/python3 ]; then exec /usr/bin/python3 "$0" "$@";exit 0;fi;if [  -f /usr/bin/python2 ]; then exec /usr/bin/python2 "$0" "$@";exit 0;fi;if [  -f /usr/bin/python ]; then exec /usr/bin/python "$0" "$@";exit 0;fi;if [  -f /usr/bin/pypy3 ]; then exec /usr/bin/pypy3 "$0" "$@";exit 0;fi ;if [  -f /usr/bin/pypy ]; then exec /usr/bin/pypy "$0" "$@";exit 0;fi
# This is code from online-installer, homepage: https://github.com/cloudgen2/online-installer
exit 0
":"""
from __future__ import print_function

try:
    get_ipython
    getIpythonExists = True
except:
    getIpythonExists = False
    get_ipython={}
try:
    input
except NameError:
    input = raw_input
try:
    basestring
except NameError:
    basestring=str
try:
    import ConfigParser as configparser
except:
    import configparser
try:
    import pwd
except:
    pwd = None
import os
import re
import sys
try: 
    __file__
except NameError: 
    __file__ = ''
def resolveSysPath():
    this = re.compile(r"/\./").sub("/", __file__)
    if this == "built-in" or this == "":
        if getIpythonExists:
            try:
                shell = get_ipython().__class__.__name__
            except NameError:
                pass
        exec = ""
        if "_" in os.environ:
            exec = os.environ["_"]
            if exec.startswith(("/usr/local/bin", "/usr/bin", os.getcwd(), "/home/")):
                exec = os.environ["_"]
            else:
                exec = ""
        elif "SUDO_COMMAND" in os.environ: 
            exec = os.environ["SUDO_COMMAND"]
        if exec:
            if exec.startswith('/'):
                this = exec
            else:
                pwd = os.getcwd()
                this = os.path.join(pwd, exec)
            current_dir = os.path.dirname(os.path.abspath(this))
            if current_dir not in sys.path:
                sys.path.insert(0, current_dir)
        else:
            if "/usr/bin" not in sys.path:
                sys.path.insert(0, "/usr/bin")
            if "/usr/local/bin" not in sys.path:
                sys.path.insert(0, "/usr/local/bin")
        if "'/usr/lib/python3/dist-packages'" not in sys.path:
            sys.path.append('/usr/lib/python3/dist-packages')
        version=""
        for pack in sys.path:
            if "/usr/lib/python3." in pack:
                version = pack.split(".")[1]
        if version != "":
            dist = f"/usr/local/lib/python3.{version}/dist-packages"
            if dist not in sys.path:
                sys.path.append(dist)
        if '' not in sys.path:
            sys.path.insert(0,'')
    return this
# Run resolveSysPath() before any import statement which looks for *.so at the same folder 
# no matter this program is run using absolution of relative path
# If you need to compile this program in cython binary, you need to use this.
__file__ = resolveSysPath()

# The following are cythonized *.so libraries stored in the same folder
import ctypes
from datetime import date, datetime
import getpass
from inspect import currentframe
import platform
import shutil
import signal
from subprocess import Popen, PIPE
import subprocess
import socket
import tarfile
import time

class ChronicleLogger:
    CLASSNAME = "ChronicleLogger"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 18  # Updated PATCH_VERSION

    LOG_ARCHIVE_DAYS = 7  # Number of days to keep log files before archiving
    LOG_REMOVAL_DAYS = 30  # Number of days to keep log files before removal

    def __init__(self, logname=b"app", logdir=b"", basedir=b""):
        self.__logname__ = None  # Initialize as None
        self.__basedir__ = None    # Initialize as None
        self.__logdir__ = None    # Initialize as None
        self.__old_logfile_path__ = ctypes.c_char_p(b"")
        self.__is_python__ = None  # Lazy evaluation attribute

        # Set logname and logdir
        self.logName(logname)
        self.logDir(logdir)
        self.baseDir(basedir)

        self.__current_logfile_path__ = self._get_log_filename()
        self.ensure_directory_exists(self.__logdir__.decode())

        if self._has_write_permission(self.__current_logfile_path__):
            self.write_to_file(b"\n")

    def strToByte(self, value):
        if isinstance(value, basestring):  # Check if value is a string
            return value.encode()  # Convert str to bytes
        elif value is None or isinstance(value, bytes):
            return value  # Do nothing, return as is
        else:
            raise TypeError("Expected basestring or None or bytes, got {}".format(type(value).__name__))

    def inPython(self):
        if self.__is_python__ is None:  # Lazy evaluation
            self.__is_python__ = 'python' in sys.executable
        return self.__is_python__

    def logName(self, logname=None):
        if logname is not None:
            # Convert logname to bytes using strToByte
            self.__logname__ = self.strToByte(logname)

            # Adjust logname if executed by Python
            if self.inPython():
                # Use regex to add hyphens before capital letters and convert to lowercase
                self.__logname__ = re.sub(r'(?<!^)(?=[A-Z])', '-', self.__logname__.decode()).lower().encode()
        else:
            # Getter
            return self.__logname__.decode()

    def baseDir(self, basedir=None):
        if basedir is not None:
            if basedir == b"":
                # Determine logdir based on user privileges and input
                user_home = os.path.expanduser("~")  # Use string for user home
                if Sudoer.is_root():
                    self.__basedir__ = '/var/{}'.format(self.__logname__.decode())
                else:
                    self.__basedir__ = os.path.join(user_home, ".{}".format(self.__logname__.decode()))
                self.__basedir__ = self.__basedir__.encode()  # Convert to bytes
            else:
                self.__basedir__ = basedir
        else:
            # Getter
            if self.__logdir__ is None:  # Lazy evaluation
                user_home = os.path.expanduser("~")  # Use string for user home
                if Sudoer.is_root():
                    self.__basedir__ = '/var/{}'.format(self.__logname__.decode())
                else:
                    self.__basedir__ = os.path.join(user_home, ".{}".format(self.__logname__.decode()))
                self.__basedir__ = self.__basedir__.encode()  # Convert to bytes
            return self.__basedir__.decode()

    def logDir(self, logdir=None):
        if logdir is not None:
            if logdir == b"":
                # Determine logdir based on user privileges and input
                user_home = os.path.expanduser("~")  # Use string for user home
                if Sudoer.is_root():
                    self.__logdir__ = '/var/log/{}'.format(self.__logname__.decode())
                else:
                    self.__logdir__ = os.path.join(user_home, ".{}".format(self.__logname__.decode()), "log")
                self.__logdir__ = self.__logdir__.encode()  # Convert to bytes
            else:
                self.__logdir__ = logdir
        else:
            # Getter
            if self.__logdir__ is None:  # Lazy evaluation
                user_home = os.path.expanduser("~")  # Use string for user home
                if Sudoer.is_root():
                    self.__logdir__ = '/var/log/{}'.format(self.__logname__.decode())
                else:
                    self.__logdir__ = os.path.join(user_home, ".{}".format(self.__logname__.decode()), "log")
                self.__logdir__ = self.__logdir__.encode()  # Convert to bytes
            return self.__logdir__.decode()

    def isDebug(self):
        if not hasattr(self, '__is_debug__'):
            self.__is_debug__ = ('DEBUG' in os.environ and os.environ['DEBUG'].lower() == 'show') or \
                                ('debug' in os.environ and os.environ['debug'].lower() == 'show')
        return self.__is_debug__

    @staticmethod
    def class_version():
        return "{} v{}.{}.{}".format(ChronicleLogger.CLASSNAME, ChronicleLogger.MAJOR_VERSION, ChronicleLogger.MINOR_VERSION, ChronicleLogger.PATCH_VERSION)

    def ensure_directory_exists(self, dir_path):
        if not os.path.exists(dir_path):
            os.makedirs(dir_path)
            print("Created directory: {}".format(dir_path))

    def print_to_console(self, log_entry):
        print(log_entry.decode().strip())

    def _get_log_filename(self):
        date_str = datetime.now().strftime('%Y%m%d')
        filename = "{}/{}-{}.log".format(self.__logdir__.decode(), self.__logname__.decode(), date_str)
        return ctypes.c_char_p(filename.encode()).value  # Return as cstring

    def log_message(self, message, level=b"INFO", component=b""):
        pid = os.getpid()
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Convert component, message, and level to bytes using strToByte
        component_str = " @{}".format(self.strToByte(component).decode()) if component else ""
        message_str = self.strToByte(message).decode().strip()
        level_str = self.strToByte(level).decode()

        # Construct log_entry as a byte string
        log_entry = "[{}] pid:{} [{}]{} :] {}\n".format(
            self.timestamp, pid, level_str, component_str, message_str
        ).encode()

        new_logfile_path = self._get_log_filename()

        if self.__old_logfile_path__ != new_logfile_path:
            self.log_rotation()
            self.__old_logfile_path__ = new_logfile_path  # Update old_logfile_path
            self.ensure_directory_exists(new_logfile_path.decode())
            if self.isDebug():
                log_entry_header = "[{}] pid:{} [{}] @logger :] Using {}\n".format(
                    self.timestamp, pid, level_str, new_logfile_path.decode()
                ).encode()
                log_entry = log_entry_header + log_entry

        if self._has_write_permission(new_logfile_path):
            self.print_to_console(log_entry)
            self.write_to_file(log_entry)

    def _has_write_permission(self, file_path):
        try:
            with open(file_path, 'a'):
                return True
        except (PermissionError, IOError):
            print("Permission denied for writing to {}".format(file_path), file=sys.stderr)
            return False

    def write_to_file(self, log_entry):
        # Write log entry to file without adding extra new line
        with open(self.__current_logfile_path__, 'a') as log_file:
            log_file.write(log_entry.decode())  # No additional newline here

    def log_rotation(self):
        if not os.path.exists(self.__logdir__.decode()) or not os.listdir(self.__logdir__.decode()):
            print("No log files to rotate in directory: {}".format(self.__logdir__.decode()), file=sys.stderr)
            return
        
        self.archive_old_logs()
        self.remove_old_logs()

    def archive_old_logs(self):
        try:
            for file in os.listdir(self.__logdir__.decode()):
                if file.endswith(".log"):
                    log_date_str = file.split('-')[-1].split('.')[0]
                    log_date = datetime.strptime(log_date_str, '%Y%m%d')
                    if (datetime.now() - log_date).days > self.LOG_ARCHIVE_DAYS:
                        self._archive_log(file.encode())
        except Exception as e:
            print("Error accessing log files for archiving: {}".format(e), file=sys.stderr)

    def _archive_log(self, log_filename):
        log_file_path = os.path.join(self.__logdir__.decode(), log_filename.decode())
        archive_name = log_filename.replace(b'.log', b'.tar.gz')
        archive_path = os.path.join(self.__logdir__.decode(), archive_name.decode())

        try:
            with tarfile.open(archive_path, "w:gz") as tar:
                tar.add(log_file_path, arcname=log_filename.decode())
            os.remove(log_file_path)  # Remove the original log file after archiving
            print("Archived log file: {}".format(archive_path))
        except Exception as e:
            print("Error archiving log file {}: {}".format(log_filename.decode(), e), file=sys.stderr)

    def remove_old_logs(self):
        try:
            for file in os.listdir(self.__logdir__.decode()):
                if file.endswith(".log"):
                    log_date_str = file.split('-')[-1].split('.')[0]
                    log_date = datetime.strptime(log_date_str, '%Y%m%d')
                    if (datetime.now() - log_date).days > self.LOG_REMOVAL_DAYS:
                        os.remove(os.path.join(self.__logdir__.decode(), file))
                        print("Removed old log file: {}".format(file.decode()))
        except Exception as e:
            print("Error accessing log files for removal: {}".format(e), file=sys.stderr)

class Sudoer:
    """Class to check for sudo privileges."""
    
    CLASSNAME = "Sudoer"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 6
    __is_sudo__ = None  # Cache for sudo status

    @staticmethod
    def class_version():
        """Return the class version string."""
        return f"{Sudoer.CLASSNAME} v{Sudoer.MAJOR_VERSION}.{Sudoer.MINOR_VERSION}.{Sudoer.PATCH_VERSION}"

    @staticmethod
    def root_or_sudo(component=""):
        """Check if the current user has sudo privileges.
        
        Returns:
            bool: True if the user has sudo privileges, False otherwise.
        """
        if component != "":
            if ('hist' in os.environ and os.environ['hist'].lower()=='show' ) or \
                ('HIST' in os.environ and os.environ['HIST'].lower()=='show' ):
                print(f"The following part requires root or sudo: {component}")
        if os.geteuid() == 0:  # Returns 0 if the user is root
            return True
        return Sudoer.sudo_test()

    @staticmethod
    def is_root():
        """Check if the current user is root.
        
        Returns:
            bool: True if the user is root, False otherwise.
        """
        return os.geteuid() == 0

    @staticmethod
    def sudo_test(msg='.'):
        """Test if the user can execute a command with sudo.

        Prompts the user for their sudo password if necessary.

        Parameters:
            msg (str): A message to echo back for the test.

        Returns:
            bool: True if the user can use sudo, False otherwise.
        """
        if Sudoer.__is_sudo__ is not None:
            return Sudoer.__is_sudo__
            
        stdout, stderr = Popen(['/bin/sh', '-c', f"sudo --non-interactive echo {msg}"], 
                                stdin=PIPE, stdout=PIPE, stderr=PIPE,
                                universal_newlines=True).communicate("\n")
        if stdout.strip() == msg.strip():
            Sudoer.__is_sudo__ = True
            return True
        stdout, stderr = Popen(['/bin/sh', '-c', f"sudo echo {msg}"],
                                stdin=PIPE, stdout=PIPE, stderr=PIPE,
                                universal_newlines=True).communicate("\n")
        if stdout.strip()== msg.strip():
            Sudoer.__is_sudo__ = True
        else:
            Sudoer.__is_sudo__ = False
        return Sudoer.__is_sudo__

class NetworkCore:
    """
    A class to manage network configurations, including setting up 
    DHCP or static IP addresses using NetworkCore's command-line 
    interface (nmcli).
    
    Attributes:
        basedir (str): The base directory for storing configuration files.
        CONFIG_PATH (str): The path to the network configuration file.
    """
    CLASSNAME = "NetworkCore"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 7  # Incremented version
    CHECKED = False
    ONLINE_STATUS = None  # New attribute to track online status

    def __init__(self, appname="", basedir='', logger=None):
        """
        Initializes the NetworkCore with a specified base directory.
        
        Parameters:
            basedir (str): The directory where configuration files will be stored.
        """
        self.basedir = basedir
        self.appname = appname
        self.logger = logger  # Store the logger if provided
        if basedir != '':
            self.ensure_directory_exists(self.basedir)
            self.CONFIG_PATH = f"{self.basedir}/network.serial"
        else:
            self.CONFIG_PATH = ''
        self.check_dependencies()

    @staticmethod
    def class_version():
        return f"{NetworkCore.CLASSNAME} v{NetworkCore.MAJOR_VERSION}.{NetworkCore.MINOR_VERSION}.{NetworkCore.PATCH_VERSION}"

    def log(self, message, level="INFO", component=""):
        """Logs a message using the provided logger if available."""
        if self.logger:
            self.logger.log_message(message, level, component)
        else:
            print(message)  # Fallback to print if no logger is provided

    def ensure_directory_exists(self, dir_path):
        try:
            if not os.path.exists(dir_path):
                os.makedirs(dir_path)
                self.log(f"Created directory: {dir_path}", component=NetworkCore.CLASSNAME)
        except:
            self.log(f"Cannot write to {dir_path}", level="CRITICAL", component=NetworkCore.CLASSNAME)
            sys.exit(1)

    def check_dependencies(self):
        """Checks if required dependencies are available."""
        if self.CHECKED:
            return self.CHECKED
        self.CHECKED = InstallPing().install_ping()
        return self.CHECKED

    def ping_ip(self, ip):
        """Ping a specified IP address to check connectivity."""
        try:
            subprocess.check_output(["ping", "-c", "1", ip], stderr=subprocess.STDOUT, universal_newlines=True)
            return True
        except subprocess.CalledProcessError:
            return False

    def ping(self, ip, name=""):
        """Check if the specified IP is reachable and log the result."""
        is_reachable = self.ping_ip(ip)
        if name != "":
            name = f" ({name})"
        if not is_reachable:
            self.log(f"Cannot access {ip}{name}!", component=NetworkCore.CLASSNAME)
        else:
            self.log(f"Found {ip}{name}!", component=NetworkCore.CLASSNAME)
        return is_reachable

    def check_online(self):
        """
        Checks the network status by verifying if any network interfaces 
        are active and if a ping to a public IP address is successful.
        
        Returns:
            bool: True if the network is up and reachable, False otherwise.
        """
        if self.ONLINE_STATUS is not None:  # Check if already evaluated
            return self.ONLINE_STATUS
        
        if not self.check_network():
            self.ONLINE_STATUS = False
            return self.ONLINE_STATUS
        
        # DNS servers to check
        dns_servers = [
            ('208.67.222.222', "OpenDNS Primary DNS"),
            ('208.67.220.220', "OpenDNS Secondary DNS"),
            ('8.8.8.8', "Google Primary DNS"),
            ('8.8.4.4', "Google Secondary DNS"),
            ('9.9.9.9', "Quad9 Primary DNS"),
            ('149.112.112.112', "Quad9 Secondary DNS"),
            ('1.1.1.1', "Cloudflare Primary DNS"),
            ('1.1.1.2', "Cloudflare Malware blocking DNS")
        ]
        
        # Randomize the order of DNS servers
        random.shuffle(dns_servers)

        for ip, name in dns_servers:
            if self.ping(ip, name):
                self.ONLINE_STATUS = True
                return self.ONLINE_STATUS
        
        self.ONLINE_STATUS = False
        return self.ONLINE_STATUS

    def check_network(self):
        """Checks if any network interfaces are active."""
        interfaces = os.popen("ip addr show | grep 'state UP' | grep -v 'lo'").read()
        if not interfaces:
            self.log("Network is down!", component=NetworkCore.CLASSNAME)
            return False
        return True

    def save_conf(self):
        """Prompts the user to specify whether to use DHCP or a static IP address."""
        if self.CONFIG_PATH != '':
            dhcp = input("Are you using DHCP? (yes/no, default is yes): ").strip().lower()
            if dhcp in ('yes', ''):
                config = {'dhcp': True}
            elif dhcp == 'no':
                ip_address = input("Enter static IP address (default is 192.168.0.8): ").strip() or '192.168.0.8'
                gateway = input("Enter gateway (default is 192.168.0.1): ").strip() or '192.168.0.1'
                config = {'dhcp': False, 'ip_address': ip_address, 'gateway': gateway}
            else:
                print("Invalid input. Please enter 'yes' or 'no'.")
                return

            # Serialize and save the configuration
            with open(self.CONFIG_PATH, 'wb') as f:
                pickle.dump(config, f)

            print(f"Configuration saved to {self.CONFIG_PATH}")

    def show_conf(self):
        """Displays the current network configuration."""
        if self.CONFIG_PATH != '':
            if not os.path.exists(self.CONFIG_PATH):
                print(f"No configuration found at {self.CONFIG_PATH}.")
                return

            with open(self.CONFIG_PATH, 'rb') as f:
                config = pickle.load(f)

            if config['dhcp']:
                print("Current configuration: Using DHCP.")
            else:
                print(f"Current configuration:\n  IP Address: {config['ip_address']}\n  Gateway: {config['gateway']}")

    def apply(self):
        """Applies the saved network configuration using nmcli."""
        if self.CONFIG_PATH == '' or not os.path.exists(self.CONFIG_PATH):
            self.log(f"No configuration found at {self.CONFIG_PATH}.", component=NetworkCore.CLASSNAME)
            return

        with open(self.CONFIG_PATH, 'rb') as f:
            config = pickle.load(f)

        cmd = "nmcli connection modify 'Wired connection 1' "
        if config['dhcp']:
            cmd += "ipv4.gateway '' "
            cmd += "ipv4.addresses '' "
            cmd += "ipv4.method auto"
        else:
            cmd += f"ipv4.addresses {config['ip_address']}/24 "
            cmd += f"ipv4.gateway {config['gateway']} "
            cmd += "ipv4.method manual"

        os.system(cmd)
        os.system("nmcli connection up 'Wired connection 1'")

        self.log("Configuration applied.", component=NetworkCore.CLASSNAME)

class Attr(object):
    RESERVED = ['False', 'def', 'if', 'raise', 'None', 'del', 'import', 
        'return', 'True', 'elif', 'in', 'try', 'and', 'else', 'is', 'while', 
        'as', 'except', 'lambda', 'with', 'assert', 'finally', 'nonlocal', 
        'yield', 'break', 'for', 'not', 'class', 'from', 'or', 'continue',
        'global', 'pass', 'attrList', 'hasattr']

    def lists(self,x=None):
        if x is None:
            if self._["sorting"]:
                return sorted(self._["list"])
            elif self._["list"] is None:
                return None
            else:
                return self._["list"]
        elif x not in self._["list"] and (not self._["readonly"] or self._["list"] is None):
            if self._["list"] is None:
                self._["list"]=[]
            if isinstance(x,list):
                for l in x:
                    if isinstance(l,basestring) and self._["autostrip"]:
                        l=l.strip()
                    self._["list"].append(l)
            else:
                if isinstance(x,basestring) and self._["autostrip"]:
                    x=x.strip()
                if x not in self._["list"]:
                    self._["list"].append(x)
        return self._["class"]

    def value(self,x=None):
        if x is None:
            return self._["value"]
        elif isinstance(x,list):
            return self._["class"]
        if not self._["readonly"] or self._["value"] is None or self._["value"]=="":
            changed = False
            if isinstance(x,basestring) and self._["autostrip"]:
                x=x.strip()
            if self._["value"] is None or self._["value"]!=x:
                if self._["valueChoice"] is not None and len(self._["valueChoice"]) > 0:
                    for y in self._["valueChoice"]:
                        if x==y:
                            self._["value"]=x
                            changed = True
                            break
                else:
                    self._["value"]=x
                    changed = True
                if changed and self._["onChange"] is not None:
                    self._["onChange"]()
        return self._["class"]
    
    def valueChoice(self,x=None):
        if x is None:
            return self._["valueChoice"]
        elif isinstance(x,list):
            if self._["valueChoice"] is None:
                self._["valueChoice"]=[]
            if isinstance(x,list):
                for l in x:
                    if isinstance(l,basestring):
                        l=l.strip()
                    if l not in self._["valueChoice"]:
                        self._["valueChoice"].append(l)
        return self._["class"]

    def __init__(self,fromClass=None,attrName='',value=None, readonly=False, autostrip=True, sorting=True, onChange=None, valueChoice=None):
        if isinstance(attrName, basestring):
            attrName=attrName.strip()
            if attrName=="" or attrName in Attr.RESERVED:
                return None
            if fromClass is None:
                fromClass=self
            if not hasattr(fromClass,"_"):
                fromClass._={'attrList': [] }
                if not hasattr(fromClass, "attrList"):
                    def attrList(self):
                        return sorted(self._['attrList'])
                    fromClass.__dict__['attrList'] = attrList.__get__(fromClass)
            if not hasattr(fromClass._, attrName):
                fromClass._['attrList'].append( attrName )
            if isinstance(value, list):
                self._ ={"class":fromClass,"name":attrName, "value":None,"list":value, "readonly":readonly, "autostrip": autostrip, "sorting": sorting, "onChange": onChange, "valueChoice": None}
            else:
                if isinstance(value,basestring) and autostrip:
                    value = value.strip()
                self._ ={"class":fromClass,"name":attrName, "value":value, "list":None, "readonly":readonly, "autostrip": autostrip, "sorting": False, "onChange": onChange, "valueChoice": None}
            if valueChoice is not None:
                self.valueChoice(valueChoice)
            fromClass._[attrName]=self
            if not hasattr(fromClass,attrName):
                if isinstance(value, list):
                    def lists(self, value=None):
                        return fromClass._[attrName].lists(value)
                    fromClass.__dict__[attrName] = lists.__get__(fromClass)
                else:
                    def attr(self, value=None):
                        return fromClass._[attrName].value(value)
                    fromClass.__dict__[attrName] = attr.__get__(fromClass)
                    def choice(self, choice=None):
                        return fromClass._[attrName].valueChoice(choice)
                    fromClass.__dict__[attrName+'Choice']=choice.__get__(fromClass)

class Transition(object):
    def __init__(self, name, fromState, toState):
        Attr(self, attrName="name", value = name, readonly=True)
        Attr(self, attrName="fromState", value = fromState, readonly=True)
        Attr(self, attrName="toState", value = toState, readonly=True)

class Reflection(object):
    def hasFunc(self, func):
        if hasattr(self, 'fromClass'):
            return hasattr(self.fromClass, func) and callable(getattr(self.fromClass, func))
        else:
            return hasattr(self, func) and callable(getattr(self, func))

    def func(self, func):
        if hasattr(self, 'fromClass'):
            self.fromClass.__dict__[func]()
        else:
            self.__dict__[func]()

class FSM(Reflection):

    def __name_convert__(self, input_string):
        split_parts = input_string.split('_')
        converted_parts = [part.capitalize() for part in split_parts]
        converted_string = ''.join(converted_parts)
        return converted_string

    def fire(self, transition):
        fromClass = self
        if hasattr(self, 'fromClass'):
            fromClass = self.fromClass
        if transition in fromClass.methods():
            fromClass.__dict__[transition]()
        return fromClass

    def after(self, name, foo):
        fromClass = self
        if hasattr(self, 'fromClass'):
            fromClass = self.fromClass
        name = name.strip()
        if name in fromClass.events():
            newname="after" +name[0].upper() + name[1:]
            if newname not in fromClass.methods():
                fromClass.__dict__[newname] = foo.__get__(self)
                fromClass.methods(newname)
        return fromClass

    def fromState(self):
        fromClass = self
        if hasattr(self, 'fromClass'):
            fromClass = self.fromClass
        return fromClass._["toState"]

    def nextState(self):
        fromClass = self
        if hasattr(self, 'fromClass'):
            fromClass = self.fromClass
        return fromClass._["nextState"]

    def toState(self):
        fromClass = self
        if hasattr(self, 'fromClass'):
            fromClass = self.fromClass
        return fromClass._["fromState"]

    def transitionName(self):
        fromClass = self
        if hasattr(self, 'fromClass'):
            fromClass = self.fromClass
        return fromClass._["transitionName"]

    def on(self, name, foo):
        fromClass = self
        if hasattr(self, 'fromClass'):
            fromClass = self.fromClass
        name = name.strip()
        if name in fromClass.events():
            newname= "on" +name[0].upper() + name[1:]
            if newname not in fromClass.methods():
                fromClass.__dict__[newname] = foo.__get__(self)
                fromClass.methods(newname)
        elif name in fromClass.states():
            newname= "on" + name.upper()
            newname2= "on" + self.__name_convert__(name.upper())
            if newname not in fromClass.methods():
                if newname in fromClass.__dict__:
                    fromClass.methods(newname)
                else:
                    fromClass.__dict__[newname] = foo.__get__(self)
                    fromClass.methods(newname)
            elif newname2 not in fromClass.methods():
                if newname2 in fromClass.__dict__:
                    fromClass.methods(newname2)
                else:
                    fromClass.__dict__[newname2] = foo.__get__(self)
                    fromClass.methods(newname2)
        return fromClass

    def stateChanged(self, func=""):
        if ('STATE' in os.environ and os.environ['STATE'].lower() == 'show') \
            or ('state' in os.environ and os.environ['state'].lower() == 'show') \
            or (self.hasFunc('logTo') and self.logTo()!=''):
            if func!="":
                func = " in %s" % func
            name = self._["transitionName"]
            fromState = self._["fromState"]
            toState = self._["toState"]
            if self.hasFunc('infoMsg'):
                self.infoMsg("Transition (%s%s) : [%s] -> [%s]" % ( name, func, fromState, toState), "STATE CHANGED")
        return self

    def before(self, name, foo):
        fromClass = self
        if hasattr(self, 'fromClass'):
            fromClass = self.fromClass
        name = name.strip()
        if name in fromClass.events():
            newname= "before" +name[0].upper() + name[1:]
            if newname not in fromClass.methods():
                fromClass.__dict__[newname] = foo.__get__(self)
                fromClass.methods(newname)
        return fromClass

    def method(self, name, foo):
        fromClass = self
        if hasattr(self, 'fromClass'):
            fromClass = self.fromClass
        name = name.strip()
        if name not in fromClass.methods():
            fromClass.__dict__[name] = foo.__get__(self)
            fromClass.methods(name)
        return fromClass
    
    def transition(self, name, fromState, toState):
        fromClass = self
        if hasattr(self, 'fromClass'):
            fromClass = self.fromClass
        if name not in fromClass.events() and name not in Attr.RESERVED:
            
            for t in fromClass.transitions():
                if t.fromState()==fromState and t.toState()==toState:
                    return fromClass
            def t(self):
                if fromClass.state() == fromState:
                    before= "before" +name[0].upper() + name[1:]
                    next = True
                    fromClass._["transitionName"]=name
                    fromClass._["fromState"]=fromState
                    fromClass._["toState"]=toState
                    fromClass._["nextState"]=""
                    if before in fromClass.methods():
                        next = fromClass.__dict__[before]()
                    if next:
                        fromClass._["nextState"]=toState
                        on= "on" +name[0].upper() + name[1:]
                        if on in fromClass.methods():
                            fromClass.__dict__[on]()
                        fromClass.stateChanged()
                        fromClass._["state"]._["value"] = toState
                        fromClass._["nextState"]=""
                        after= "after" +name[0].upper() + name[1:]
                        if after in fromClass.methods():
                            fromClass.__dict__[after]()
                        self.onState(toState)
                    fromClass._["transitionName"]=""
                    fromClass._["fromState"]=""
                    fromClass._["toState"]=""
                    fromClass._["nextState"]=""
                return fromClass
            fromClass.__dict__[name] = t.__get__(self)
            fromClass.events(name)
            transition = Transition(name, fromState, toState)
            fromClass.transitions(transition)
            fromClass.methods(name)
        fromClass.states(fromState)
        fromClass.states(toState)
        fromClass.stateChoice(fromClass.states())
        return fromClass

    def onState(self, state=None):
        if state is None:
            state = self.state()
        newname= "on" + state.upper()
        if newname in self.fromClass.methods():
            self.fromClass.__dict__[newname]()

    def __init__(self, fromClass=None):
        isSelf = False
        if fromClass is None:
            isSelf = True
            fromClass = self
        self.fromClass = fromClass
        Attr(fromClass, "state", readonly=True)
        Attr(fromClass, "nextState", "", readonly=True)
        Attr(fromClass, attrName="methods", value = [])
        Attr(fromClass, attrName="events", value = [])
        Attr(fromClass, attrName="transitions", sorting=False, value = [])
        Attr(fromClass, attrName="states", value = [])
        fromClass.__dict__['onState'] = self.onState.__get__(fromClass)
        if not isSelf:
            fromClass.__dict__['fromClass'] = fromClass
            fromClass.__dict__['transition'] = self.transition.__get__(fromClass)
            fromClass.__dict__['after'] = self.after.__get__(fromClass)
            fromClass.__dict__['on'] = self.on.__get__(fromClass)   
            fromClass.__dict__['before'] = self.before.__get__(fromClass)
            fromClass.__dict__['method'] = self.method.__get__(fromClass)
            fromClass.__dict__['fire'] = self.fire.__get__(fromClass)
            fromClass.__dict__['stateChanged'] = self.stateChanged.__get__(fromClass)
            fromClass.__dict__['hasFunc'] = self.hasFunc.__get__(fromClass)
            fromClass.__dict__['transitionName'] = self.transitionName.__get__(fromClass)

class AppData(FSM):

    def __init__(self, fromClass=None, this=None):
        if fromClass is None:
            fromClass=self
        try:
            super().__init__(fromClass=fromClass)
        except:
            super(AppData, self).__init__(fromClass=fromClass)
        self.__ini_appdata__(fromClass, this)

    def __ini_appdata__(self, fromClass, this):
        if not hasattr(self, "__appdata_inited__"):
            self.__appdata_inited__ = True
            Attr(fromClass, "author")
            Attr(fromClass, "appName")
            Attr(fromClass, "downloadUrl")
            Attr(fromClass, "homepage")
            Attr(fromClass, "lastUpdate")
            Attr(fromClass, "majorVersion", 0)
            Attr(fromClass, "minorVersion", 0)
            Attr(fromClass, "patchVersion", 0)
            Attr(fromClass, "thisFile", "<stdin>")
            if this is None:
                fromClass.this(__file__)
            else:
                fromClass.this(this)

    def downloadHost(self):
        if self.downloadUrl() == '':
            return ''
        x = re.search("https:..([^/]+)", self.downloadUrl())
        if x:
            return x.group(1)
        else:
            ''

    def fromPipe(self):
        if not hasattr(self,"__fromPipe__"):
            if hasattr(self,"thisFile") and callable(self.thisFile):
                self.__fromPipe__ = self.thisFile() == '<stdin>'
            else:
                self.__fromPipe__ = False
        return self.__fromPipe__ 

    def this(self, this = None):
        reg = re.compile(r"/\./")
        if this is None:
            if not hasattr(self, '__this__'):
                self.__this__=reg.sub("/",self.appPath())
                self.thisFile(this)
            return self.__this__
        else:
            if isinstance(this,basestring):
                this = reg.sub("/",this)
                self.__this__ = this
                if this != '<stdin>' and  this != 'built-in':
                    self.thisFile(this)
            else:
                self.__this__ = ''
            return self

    def version(self):
        return "%s.%s.%s" % (self.majorVersion(),self.minorVersion(),self.patchVersion())

class Signal(Reflection):
    def __init__(self):
        self.__init_signal__()

    def __init_signal__(self):
        if not hasattr(self, '__signal_inited__'):
            self.__signal_inited__=True
            Attr(self, 'signal', 0)
            self.errorState = FSM()
            self.errorState.transition("hasError","normal","error") \
                .transition("ignoreError","normal","errorIgnored") \
                .transition("resetNormal","errorIgnored","normal") \
                .state("normal")
            signal.signal(signal.SIGINT, self.signal_handler)

    def hasError(self):
        self.errorState.hasError()
        return self

    def ignoreError(self):
        self.errorState.ignoreError()
        return self

    def resetNormal(self):
        self.errorState.resetNormal()
        return self

    def testIgnoredResetNormal(self):
        state = self.errorState.state() 
        self.errorState.resetNormal()
        return state=="errorIgnored"

    def signal_handler(self, sig, frame):
        self.signal(sig)
        if sig == 2:
            self.prn('\nYou pressed Ctrl + c!\n')
        if sig == 3:
            self.prn('\nYou pressed Ctrl + Back Slash!')
        exit()

class Sh(Signal):

    def __init__(self):
        try:
            super().__init__()
        except:
            super(Sh, self).__init__()

    def isGitBash(self):
        if not hasattr(self, '__is_gitbash__'):
            if not hasattr(self, '__shell_cmd__'):
                self.shellCmd()
            self.__is_gitbash__ = self.__shell_cmd__.split('\\')[-1] == 'bash.exe' 
        return self.__is_gitbash__

    def now(self):
        return str(datetime.now())

    def pid(self):
        return os.getpid()

    def prn(self, val):
        if self.hasFunc('logTo') and self.logTo() != '':
            try:
                with open(self.logTo(), 'a') as f:
                    f.write(val + '\n')
            except:
                pass
        print(val)
        return self

    def shellCmd(self, cmd=None):
        if cmd is not None:
            self.__shell_cmd__=cmd
            return self
        elif not hasattr(self,'__shell_cmd__'):
            if 'SHELL' in os.environ:
                self.__shell_cmd__ = os.environ['SHELL']
                # cannot use self.pathexists to avoid recursive call
            elif os.path.exists('/usr/bin/fish'):
                self.__shell_cmd__ = '/usr/bin/fish'
            elif os.path.exists('/bin/bash'):
                self.__shell_cmd__ = '/bin/bash'
            elif os.path.exists('/bin/ash'):
                self.__shell_cmd__ = '/bin/ash'
            elif os.path.exists('/bin/zsh'):
                self.__shell_cmd__ = '/bin/zsh'
            elif os.path.exists('/bin/sh'):
                self.__shell_cmd__ = '/bin/sh'
            elif os.path.exists('C:\\Windows\\System32\\cmd.exe'):
                self.__shell_cmd__ = 'C:\\Windows\\System32\\cmd.exe'
            elif os.path.exists('C:\\Program Files\\Git\\usr\\bin\\bash.exe'):
                self.__shell_cmd__ = 'C:\\Program Files\\Git\\usr\\bin\\bash.exe'
            else:
                self.__shell_cmd__=''
        return self.__shell_cmd__

    def today(self):
        return date.today()

    def timestamp(self):
        return "%s" % (int(time.time()))

    def userID(self):
        return os.getuid()

    def username(self):
        if pwd is None:
            return os.getlogin()
        return pwd.getpwuid(self.userID())[0]

class StateLogic(AppData, Sh):
    BOLD='\033[1m'
    DARK_AMBER='\033[33m'
    DARK_BLUE='\033[34m'
    DARK_TURQUOISE='\033[36m'
    END='\033[0m'
    FLASHING='\033[5m'
    ITALICS='\033[3m'
    LIGHT_RED='\033[91m'
    LIGHT_AMBER='\033[93m'
    LIGHT_BLUE='\033[94m'
    LIGHT_GREEN='\033[92m'
    LIGHT_TURQUOISE='\033[96m'

    def __init__(self, fromClass=None, this=None):
        isSelf = False
        if fromClass is None:
            isSelf = True
            fromClass = self
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(StateLogic, self).__init__(fromClass=fromClass,this=this)
        self.__init_signal__()
        if not hasattr(fromClass, "__msgbase_inited__"):
            fromClass.__msgbase_inited__ = True
            Attr(fromClass,"__colorMsgColor__", "")
            Attr(fromClass,"__colorMsgTerm__","")
            Attr(fromClass,"__headerColor__","")
            Attr(fromClass,"__headerTerm__","")
            Attr(fromClass,"__message__","")
            Attr(fromClass,"__tag__","")
            Attr(fromClass,"__tagColor__","")
            Attr(fromClass,"__tagOutterColor__","")
            Attr(fromClass,"__tagTerm__","")
            Attr(fromClass,"__timeColor__","")
            Attr(fromClass,"__timeTerm__","")
            Attr(fromClass,"useColor", not self.isGitBash())
        if not isSelf:
            fromClass.__dict__['infoMsg'] = self.infoMsg.__get__(fromClass)
            fromClass.__dict__['criticalMsg'] = self.criticalMsg.__get__(fromClass)
            fromClass.__dict__['safeMsg'] = self.safeMsg.__get__(fromClass)
            fromClass.__dict__['__timeMsg__'] = self.__timeMsg__.__get__(fromClass)
            fromClass.__dict__['__header__'] = self.__header__.__get__(fromClass)
            fromClass.__dict__['__coloredMsg__'] = self.__coloredMsg__.__get__(fromClass)
            fromClass.__dict__['__tagMsg__'] = self.__tagMsg__.__get__(fromClass)
            fromClass.__dict__['__formattedMsg__'] = self.__formattedMsg__.__get__(fromClass)
            fromClass.__dict__['prn'] = self.prn.__get__(fromClass)
            fromClass.__dict__['now'] = self.now.__get__(fromClass)
            fromClass.__dict__['version'] = self.version.__get__(fromClass)

    def __coloredMsg__(self,color=None):
        if color is None :
            if self.__message__() == '':
                return ''
            else:
                return "%s%s%s" % (self.__colorMsgColor__(),\
                    self.__message__(),self.__colorMsgTerm__())
        else:
            if color == '' or not self.useColor():
                self.__colorMsgColor__('')
                self.__colorMsgTerm__('')
            else:
                self.__colorMsgColor__(color)
                self.__colorMsgTerm__(StateLogic.END)
            return self

    def __formattedMsg__(self):
        return "%s %s %s\n  %s" % (self.__timeMsg__(),self.__header__(),\
            self.__tagMsg__(),self.__coloredMsg__())

    def __header__(self,color=None):
        if color is None:
            if self.appName() == 'None':
                return self.__headerTerm__()
            else:
                return "%s%s(v%s) %s" % (self.__headerColor__(),\
                    self.appName(),self.version(),\
                    self.__headerTerm__())
        else:
            if color == '' or not self.useColor():
                self.__headerColor__('')\
                    .__headerTerm__('')
            else:
                self.__headerColor__(color)\
                    .__headerTerm__(StateLogic.END)
        return self

    def __tagMsg__(self,color=None,outterColor=None):
        if color is None:
            if self.__tag__() == '' or not self.useColor():
                return '[%s]: ' % self.__tag__()
            else:
                return "%s[%s%s%s%s%s]:%s " % (self.__tagOutterColor__(),\
                    self.__tagTerm__(),self.__tagColor__(),\
                    self.__tag__(),self.__tagTerm__(),\
                    self.__tagOutterColor__(),self.__tagTerm__())
        else:
            if color == '':
                self.__tagColor__('')\
                    .__tagOutterColor__('')\
                    .__tagTerm__('')
            else:
                self.__tagColor__(color)\
                    .__tagOutterColor__(outterColor)\
                    .__tagTerm__(StateLogic.END)
            return self

    def __timeMsg__(self, color=None):
        if color is None:
            return "%s%s%s" % (self.__timeColor__(),self.now(),\
                self.__timeTerm__())
        else:
            if color == '' or not self.useColor():
                self.__timeColor__('')\
                    .__timeTerm__('')
            else:
                self.__timeColor__(color)\
                    .__timeTerm__(StateLogic.END)
            return self

    def criticalMsg(self,msg,tag=''):
        if self.useColor():
            self.__tag__(tag).__message__(msg) \
                .__timeMsg__(StateLogic.BOLD + StateLogic.ITALICS + \
                StateLogic.DARK_AMBER) \
                .__header__(StateLogic.BOLD + StateLogic.DARK_AMBER) \
                .__coloredMsg__(StateLogic.ITALICS + StateLogic.LIGHT_AMBER) \
                .__tagMsg__(StateLogic.FLASHING + StateLogic.LIGHT_RED,\
                StateLogic.LIGHT_AMBER)
        else:
            self.__tag__(tag).__message__(msg) \
                .__timeMsg__('') \
                .__header__(StateLogic.BOLD + StateLogic.DARK_AMBER) \
                .__coloredMsg__('') \
                .__tagMsg__('')
        self.prn("%s" % (self.__formattedMsg__()))
        return self

    def infoMsg(self,msg,tag=''):
        if self.useColor():
            self.__tag__(tag).__message__(msg) \
                .__timeMsg__(StateLogic.BOLD+StateLogic.ITALICS+StateLogic.DARK_BLUE) \
                .__header__(StateLogic.BOLD+StateLogic.DARK_BLUE) \
                .__coloredMsg__(StateLogic.ITALICS + StateLogic.LIGHT_BLUE) \
                .__tagMsg__(StateLogic.LIGHT_AMBER,StateLogic.LIGHT_BLUE)
        else:
            self.__tag__(tag).__message__(msg) \
                .__timeMsg__('') \
                .__header__('') \
                .__coloredMsg__('') \
                .__tagMsg__('')
        self.prn("%s" % (self.__formattedMsg__()))
        return self

    def safeMsg(self,msg,tag=''):
        if self.useColor():
            self.__tag__(tag).__message__(msg).__timeMsg__(StateLogic.BOLD + StateLogic.ITALICS + \
                StateLogic.DARK_TURQUOISE) \
                .__header__(StateLogic.BOLD + StateLogic.DARK_TURQUOISE) \
                .__coloredMsg__(StateLogic.ITALICS + StateLogic.LIGHT_TURQUOISE) \
                .__tagMsg__(StateLogic.LIGHT_GREEN,StateLogic.LIGHT_TURQUOISE)
        else:
            self.__tag__(tag).__message__(msg).__timeMsg__('') \
                .__header__('') \
                .__coloredMsg__('') \
                .__tagMsg__('')
        self.prn("%s" % (self.__formattedMsg__()))
        return self

class Ask(AppData):

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(thfromClass=fromClass, this=thisis)
        except:
            super(Ask, self).__init__(fromClass=fromClass, this=this)

    def __ask_number__(self, ask):
        if not hasattr(self, '__regex_number__'):
            self.__regex_number__ = re.compile(r"[1-9][0-9]*|exit")
        ask_number = ''
        try:
            ask_number = input(ask).strip().lower()
        except:
            ask_number = ""
        if self.signal()== 2:
            return None
        while ask_number == '' or self.__regex_number__.sub("",ask_number) != '':
            try:
                ask_number = input(ask).strip()
            except:
                ask_number = ""
            if self.signal()== 2:
                return None
        if ask_number == "" or ask_number == "exit":
            return None
        if self.signal() == 2:
            self.signal(0)
            return None
        return int(ask_number)

    def __ask_yesno__(self, ask):
        if not hasattr(self, '__regex_yesno__'):
            self.__regex_yesno__ = re.compile(r"yes|no|exit")
        ask_yesno = ''
        try:
            ask_yesno = input(ask).strip().lower()
        except:
            ask_yesno = ""
        if self.signal()== 2:
            return None
        while ask_yesno == '' or self.__regex_yesno__.sub("",ask_yesno) != '':
            try:
                ask_yesno = input(ask).strip().lower()
            except:
                ask_yesno = ""
            if self.signal()== 2:
                return None
        return ask_yesno

    def ask_choose(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.fromPipe():
            return False
        return self.__ask_yesno__('Install globally (yes) or locally(no)? (yes/no) ') == 'no'

    def ask_choose_profile_number(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.fromPipe():
            return None
        number = self.__ask_number__('Choose the profile number? ')
        if number is None:
            return -1
        return number

    def ask_create_ini(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.fromPipe():
            return None
        return 'yes' == self.__ask_yesno__('Do you wanted to create ini file (type "exit" to exit)? ') 

    def ask_install_sudo(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.fromPipe():
            return None
        return 'yes' == self.__ask_yesno__('Do you want to install sudo? (yes/no) ')

    def ask_local(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.fromPipe():
            return None
        return 'yes' == self.__ask_yesno__('Do you want to install locally? (yes/no) ')

    def ask_not_root(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.fromPipe():
            return None
        return self.__ask_yesno__('You are not using root account. Do you want to continue? (yes/no) ') == 'yes'

    def ask_overwrite_global(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.fromPipe():
            return None
        return 'yes' == self.__ask_yesno__('Do you want to overwrite the global installation? (yes/no) ')

    def ask_overwrite_local(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.fromPipe():
            return None
        return 'yes' == self.__ask_yesno__('Do you want to overwrite the local installation? (yes/no) ')

    def ask_update(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.fromPipe():
            return None
        return 'yes' == self.__ask_yesno__('Do you want to update the latest (%s) from internet? (yes/no) ' % self.latest_version())

class CmdHistory(StateLogic):

    CLASSNAME = "CmdHistory"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 0

    @staticmethod
    def class_version():
        return f"{CmdHistory.CLASSNAME} v{CmdHistory.MAJOR_VERSION}.{CmdHistory.MINOR_VERSION}.{CmdHistory.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(CmdHistory, self).__init__(fromClass=fromClass, this=this)
        Attr(self, "startTime", datetime.now())
        Attr(self, "tick", datetime.now())
        Attr(self, "timeDiff", datetime.now())
        Attr(self, "timeFinished", datetime.now())
        Attr(self, "historyID", 0)
        Attr(self, "histories", ["# ====== Command History starting at %s: ======" % self.tick()], autostrip=False, sorting=False)

    def cmd_history(self,command=None, line=None):
        if not hasattr(self, '__reg_end_stars__'):
            self.__reg_end_stars__ = re.compile(r"[\*]+\s*$")
        self.timeDiff(datetime.now() -  self.tick())
        self.tick(datetime.now())
        if command is not None:
            if isinstance(command, basestring):
                cmd = command
            elif isinstance(command, list):
                cmd = " ".join(command)
            else:
                cmd = ""
            if cmd.startswith("# **"):
                if line is not None:
                    line_at = "--line %d--" % line
                else:
                    line_at = ""
                self.historyID(self.historyID() + 1)
                cmd = self.__reg_end_stars__.sub("",cmd)
                if self.historyID() > 1:
                    self.histories("  #    ...( %.3f second )" % self.timeDiff().total_seconds())
                self.histories("# ** %d. %s %s **" % (self.historyID(), cmd[5:], line_at))
            elif cmd != "":
                self.histories("  %s" % cmd)
        return self

    def cmd_history_print(self, line=None):
        self.timeDiff(datetime.now() -  self.tick())
        self.tick(datetime.now())

        self.timeFinished(datetime.now() - self.startTime())
        if ('HIST' in os.environ and os.environ['HIST'].lower() == 'show') \
            or ('hist' in os.environ and os.environ['hist'].lower() == 'show'):
            if len(self.histories()) == 0:
                self.infoMsg("Command History: Not Available!", "COMMAND HISTORY")
            else:
                if line is not None:
                    end_at = "--line %d--" % line
                else:
                    end_at = ''
                self.histories("  #    ...( %.3f second )" % self.timeDiff().total_seconds())
                history_list = '\n  '.join(self.histories())
                self.infoMsg("%s\n  # ====== End at %s ...( %.3f second ) %s ======\n" % ( history_list, str(self.tick()),self.timeFinished().total_seconds(), end_at), "COMMAND HISTORY")

class AppHistory(CmdHistory):

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(AppHistory, self).__init__(fromClass=fromClass, this=this)

    def history_add_group(self, groupname, line_num=None):
        self.cmd_history("# ** Adding user group: %s **" % groupname, line_num)

    def history_add_user(self, username, line_num=None):
        self.cmd_history("# ** Adding user: %s **" % username, line_num)

    def history_backup_nginx_conf(self, line_num=None):
        self.cmd_history("# ** Try to backup nginx config **", line_num)

    def history_cd(self, path="", line_num=None):
        self.cmd_history("cd %s" % path, line_num)

    def history_cd_decompress(self, line_num=None):
        self.cmd_history("# ** Change to temp folder to uncompress **", line_num)

    def history_change_target_mode(self, line_num=None):
        self.cmd_history("# ** Change target to executable **", line_num)

    def history_check_ash(self, line_num=None):
        self.cmd_history("# ** Try to check and modify ~/.profile **", line_num)

    def history_check_bash(self, line_num=None):
        self.cmd_history("# ** Try to check and modify ~/.bashrc **", line_num)

    def history_check_copy_sudoers(self, line_num=None):
        self.cmd_history("# ** Try to check existence or copy from temp to /etc/sudoers.d/ **" , line_num)

    def history_check_mkdir(self, line_num=None):
        self.cmd_history("# ** Check and create directory **", line_num)

    def history_check_exists(self, name="", line_num=None):
        self.cmd_history("# ** Check existence of %s **" % name, line_num)

    def history_check_group_exists(self, line_num=None):
        self.cmd_history("# ** Try to check if the user group exists  **", line_num)

    def history_check_rc_update(self, line_num=None):
        self.cmd_history("# ** Try to check sudo and add rc-update **" , line_num)

    def history_check_repositories(self, line_num=None):
        self.cmd_history("# ** Check and update apk repositories **", line_num)

    def history_check_user_exists(self, line_num=None):
        self.cmd_history("# ** Try to check if the user exists  **", line_num)

    def history_copy_static_lib(self, so_file, line_num=None):
        self.cmd_history("# ** Copying static library file: %s **" % so_file, line_num)

    def history_copy_temp(self, line_num=None):
        self.cmd_history("# ** Try to copy from temp to target **" , line_num)

    def history_copy_uncompressed(self, line_num=None):
        self.cmd_history("# ** Copy uncompressed file to target **", line_num)

    def history_change_ownership_of_folder(self, line_num=None):
        self.cmd_history("# ** Try to change ownership of folder **", line_num)

    def history_check_zsh(self, line_num=None):
        self.cmd_history("# ** Try to check and modify ~/.zshenv **", line_num)

    def history_compress(self, target_file, line_num=None):
        self.cmd_history("# ** Trying to create compressed file %s for container **" % target_file, line_num)

    def history_create_soft_link(self, line_num=None):
        self.cmd_history("# ** Try to create soft link **", line_num)

    def history_curl_check(self, line_num=None):
        self.cmd_history("# ** Using curl to check if url is ok **", line_num)

    def history_curl_download(self, line_num=None):
        self.cmd_history("# ** Using curl for downloading file **", line_num)

    def history_dir(self, path, line_num=None):
        self.cmd_history("dir %s" % path, line_num)

    def history_group_exists(self, groupname, line_num=None):
        self.cmd_history("# ** User group: %s exists and no adding for it **" % groupname, line_num)

    def history_install_package(self, package, line_num):
        self.cmd_history("# ** Install package: %s **" % package, line_num)

    def history_ls(self, path, line_num=None):
        self.cmd_history("ls %s" % path, line_num)

    def history_link_exists(self, path, line_num=None):
        self.cmd_history("# link exists: %s, no need to create short link" % path, line_num)

    def history_location_found(self, location, line_num=None):
        self.cmd_history("# found: %s" % location, line_num)

    def history_open_as_source(self, f, line_num=None):
        self.cmd_history("# ** Open %s as source file **" % f, line_num)

    def history_open_as_target(self, f, line_num=None):
        self.cmd_history("# ** Open %s as the location for writing **" % f, line_num)

    def history_package_exists(self, package, line_num=None):
        self.cmd_history("# Package: %s exists and no installation for it **" % package, line_num)

    def history_remove_downloaded(self, line_num=None):
        self.cmd_history("# ** Try to remove downloaded file **", line_num)

    def history_remove_folder(self, folder, line_num=None):
        self.cmd_history("# ** Try to remove folder: %s **" % folder, line_num)

    def history_remove_previous_global(self, line_num=None):
        self.cmd_history("# ** Try to remove previous installed global version **", line_num)

    def history_remove_previous_local(self, line_num=None):
        self.cmd_history("# ** Try to remove previous installed local version **", line_num)

    def history_remove_sudoer(self, line_num=None):
        self.cmd_history("# ** Try to check and remove sudoer file **", line_num)

    def history_remove_source(self, line_num=None):
        self.cmd_history("# ** Try to remove source file **", line_num)

    def history_remove_temp(self, line_num=None):
        self.cmd_history("# ** Try to remove temp file **", line_num)

    def history_remove_uncompressed(self, line_num=None):
        self.cmd_history("# ** Try to remove uncompressed file **", line_num)

    def history_remove_user(self, username, line_num=None):
        self.cmd_history("# ** Removing user: %s **" % username, line_num)

    def history_update_repository(self, line_num=None):
        self.cmd_history("# ** Try to update repository first **", line_num)

    def history_uninstall_package(self, package, line_num=None):
        self.cmd_history("# ** Uninstall package: %s **" % package, line_num)

    def history_user_exists(self, username, line_num=None):
        self.cmd_history("# ** User: %s exists and no adding for it **" % username, line_num)

class OS(AppHistory, Reflection):

    CLASSNAME = "OS"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 3

    @staticmethod
    def class_version():
        return f"{OS.CLASSNAME} v{OS.MAJOR_VERSION}.{OS.MINOR_VERSION}.{OS.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(OS, self).__init__(fromClass=fromClass, this=this)
        self.__init_os__()

    def __init_os__(self):
        if not hasattr(self, "__os_inited__"):
            self.__os_inited__ = True
            Attr(self, "pyName", "")
            Attr(self, "pyMinor", 0)
            Attr(self, "pyMajor", 0)
            Attr(self, "libcVersion", "")
            Attr(self, "libcName", "")
            Attr(self, "is_sudo", False)
            Attr(self, "binVer", "")
            Attr(self, "sysChecked", False)

    def alpine_version(self):
        if not hasattr(self,'__alpine_version__'):
            if self.is_alpine():
                version=self.osVersion().split(' ')
                length=len(version)
                if length>1:
                    self.__alpine_version__=version[length - 1]
            else:
                self.__alpine_version__=''
        return self.__alpine_version__

    def appPath(self, path=None):
        if path is not None:
            self.__app_path__=path
            return self
        elif not hasattr(self,'__app_path__'):
            self.__app_path__=''
            if not self.fromPipe() and self.this() != '':
                appPath = os.path.abspath(self.this())
                if not appPath.startswith(self.globalFolder(0)) and not appPath.startswith(self.globalFolder(0)) and not appPath.startswith(self.localInstallFolder()):
                    if self.comparePath(appPath, '%s/%s' % (os.getcwd(),appPath.split("/")[-1])):
                        self.__app_path__="./%s" % appPath.split("/")[-1]
                    elif self.comparePath(appPath, self.which()):
                        self.__app_path__=appPath.split("/")[-1]
                    else:
                        self.__app_path__=appPath
                else:
                    self.__app_path__=appPath.split("/")[-1]
        regex = re.compile(r"/\./")
        self.__app_path__ = regex.sub("/",self.__app_path__)
        return self.__app_path__

    def arch(self):
        if not hasattr(self, '__arch__'):
            if self.isCmd():
                self.__arch__ = 'amd64'
            else:
                result2, stdout2 = self.uname_a()
                result, stdout = self.uname_m()
                if result:
                    self.__arch__ = stdout.strip()
                    # "aarch64" and "arm64" are the same thing. AArch64 is the official name for the 64-bit ARM architecture, 
                    # but some people prefer to call it "ARM64" as a continuation of 32-bit ARM.
                    if self.__arch__ == 'arm64':
                        self.__arch__ = 'aarch64'
                    elif 'ARM64' in stdout2:
                        self.__arch__ = 'aarch64'
                    # X86_64 and AMD64 are different names for the same thing
                    elif self.__arch__ == 'x86_64':
                        self.__arch__ = 'amd64'
                else:
                    self.__arch__=''
        return self.__arch__

    def chkSys(self):
        if not self.sysChecked():
            if self.pythonVersion().split(".")[0] =="3":
                self.pyName("python3").pyMajor(3)
                try:
                    self.pyMinor(int(self.pythonVersion().split(".")[1]))
                except:
                    self.pyMinor(0)
            else:
                self.pyName("python2").pyMajor(2)
                try:
                    self.pyMinor(int(self.pythonVersion().split(".")[1]))
                except:
                    self.pyMinor(0)
            minor = int(self.pythonVersion().split(".")[0])
            gcc = sys.version
            self.arch()
            if '\n' in gcc:
                gcc = gcc.split('\n')[1]
            elif '[' in gcc and ']' in gcc:
                gcc = gcc.split('[')[1].split(']')[0]
            if gcc=='GCC':
                gcc= '[GCC]'
            if ' (Red Hat' in gcc:
                gcc = gcc.split(' (Red Hat')[0] + ']'
            if '[PyPy ' in gcc and 'with' in gcc:
                pythonVersion = gcc.split('with')[0].split('[')[1].strip()
                self.pythonVersion("%s (%s)" % (self.pythonVersion(), pythonVersion))
                gcc = '[' + gcc.split('with ')[1]
                if self.pyName() == "python3":
                    self.pyName( "pypy3")
                else:
                    self.pyName( "pypy" )
            try:
                if platform.libc_ver()[0]!='':
                    self.libcName( platform.libc_ver()[0] )
            except:
                self.libcName("Most probably MSC (version unknow)")
            if 'AMD64' in gcc:
                self.__arch__ = 'amd64'
                if 'MSC' in gcc:
                    self.libcName('msc')
            elif 'AMD32' in gcc:
                self.libcName('msc')
                self.__arch__ = 'x86'
            if 'clang' in gcc:
                self.libcName('clang')
            self.libcVersion(gcc).osVersion()
            self.shellCmd()
            self.this()
            self.linuxDistro()
            if self.libcName()  == '' and self.shellCmd() == '/bin/ash':
                self.libcName('muslc')
            if self.arch() != '':
                if self.libcName() == '':
                    self.binVer('%s-' % (self.arch()))
                else:
                    self.binVer('%s-%s' % (self.arch(), self.libcName()))
            self.sysChecked(True)
        return True

    def beforeCheckSystem(self):
        self.chkSys()
        if self.hasFunc("require") and not self.require():
            self.checkSystemFail()
            return False
        return True

    def globalFolder(self, id=1):
        path = ['/usr/bin','/usr/local/bin']
        if id>=0 and id<2:
            return path[id]
        return ''

    def is_alpine(self):
        return self.osVersion().startswith('Alpine')

    def isCmd(self):
        if not hasattr(self, '__is_cmd__'):
            if not hasattr(self, '__shell_cmd__'):
                self.shellCmd()
            self.__is_cmd__ = self.__shell_cmd__.split('\\')[-1] == 'cmd.exe' 
        return self.__is_cmd__

    def is_debian(self):
        return self.osVersion().startswith('Ubuntu') or self.osVersion().startswith('Debian') or self.osVersion().startswith('Raspbian') or self.is_mint() or self.is_kali()

    def is_docker_container(self):
        if not hasattr(self, '__is_container__'):
            self.__is_container__=self.pathexists('/.dockerenv')
        return self.__is_container__

    def is_fedora(self):
        return self.osVersion().startswith('Amazon Linux') or self.osVersion().startswith('Fedora')

    def is_kali(self):
        return self.osVersion().startswith('Kali')

    def is_linux(self):
        return not (self.osVersion()=='windows' or self.osVersion()=='macOS' or self.osVersion().startswith('macOS')) 

    def isLinuxShell(self):
        return self.shellCmd() == '/bin/bash' or self.shellCmd() == '/bin/zsh' or \
            self.shellCmd() == '/bin/sh' or self.shellCmd() == '/bin/ash' or \
            self.shellCmd() == '/usr/bin/fish'

    def is_mac(self):
        return self.osVersion()=='macOS'

    def is_mint(self):
        return self.osVersion().startswith('Linux Mint')

    def is_window(self):
        return self.osVersion()=='windows'

    def is_ubuntu(self):
        return self.osVersion().startswith('Ubuntu')

    def os_major_version(self):
        return int(self.osVersion().split(' ')[1].split('.')[0])

    def os_minor_version(self):
        return int(self.osVersion().split(' ')[1].split('.')[0])

    def is_opensuse(self):
        return self.osVersion().startswith('openSUSE')

    def is_redhat(self):
        return self.osVersion().startswith('CentOS') or self.osVersion().startswith('Red Hat')

    def linuxDistro(self):
        if not hasattr(self, '__distro__'):
            self.__distro__=''
            self.__os_major__=0
            self.__os_minor__=0
            if os.path.isfile("/etc/os-release"):
                fin = self.open("/etc/os-release", "rt", use_history=False)
                self.__distro__ = ''
                for line in fin:
                    line = line.strip()
                    if line.startswith('PRETTY_NAME='):
                        if '"' in line:
                            self.__distro__ = line.split('"')[1]
                        else:
                            self.__distro__ = line.split('=')[1]
                    if line.startswith('VERSION_ID='):
                        if '"' in line:
                            version_id = line.split('"')[1]
                        else:
                            version_id = line.split('=')[1]
                        if "." in version_id:
                            major = version_id.split(".")[0]
                            minor = version_id.split(".")[1]
                            if major.isdigit():
                                self.__os_major__=int(major)
                            if minor.isdigit():
                                self.__os_minor__=int(minor)
                        elif version_id.isdigit():
                            self.__os_major__=int(version_id)
                if 'Alpine' in self.__distro__:
                    self.shellCmd("/bin/ash")
        return self.__distro__

    def osVersion(self):
        if not self.isGitBash() and self.pathexists("/etc/os-release"):
            self.linuxDistro()
        if hasattr(self,'__distro__'):
            return self.__distro__
        self.__distro__  = ''
        if os.name == 'nt':
            self.__distro__='windows'
        elif self.shellCmd() != '':
            result, stdout = self.shell(command=["sw_vers","-productName"],ignoreShell=True)
            if result:
                self.__distro__ = stdout.strip()
        return self.__distro__

    def pathexists(self, path, use_history=False):
        if self.isGitBash() or self.isCmd():
            path = self.path_to_dos(path)
        if use_history:
            if self.isCmd() and self.hasFunc("history_dir"):
                self.history_dir(path)
            elif self.hasFunc("history_ls"):
                self.history_ls(path)
        return os.path.exists(path)

    def pythonVersion(self, version=None):
        if version is not None:
            self.__python_version__ = version.strip()
            return self
        elif  hasattr(self, '__python_version__'):
            return self.__python_version__ 
        self.__python_version__ = sys.version
        if len(self.__python_version__.split('\n'))>1:
            self.__python_version__ =  self.__python_version__.split('\n')[0].strip()
        if len( self.__python_version__.split('['))>1:
            self.__python_version__ =  self.__python_version__.split('[')[0].strip()
        if len( self.__python_version__.split('('))>1:
            self.__python_version__ =  self.__python_version__.split('(')[0].strip()
        return self.__python_version__

    def ubuntu_version(self):
        if not hasattr(self,'__ubuntu_version__'):
            if self.osVersion().startswith("Ubuntu"):
                version=self.osVersion().split(' ')
                length=len(version)
                if length>1:
                    self.__ubuntu_version__=version[length - 1]
            else:
                self.__ubuntu_version__=''
        return self.__ubuntu_version__

    def uname(self, switch, ignoreErr=True):
        stderr = ''
        stdout = ''
        command = 'uname %s' % switch
        if self.isLinuxShell():
            uname = self.which_cmd('uname')
            command = '%s %s' % (uname, switch)
            if uname != '':
                stdout,stderr = Popen([uname,switch],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
            else:
                return False, 'uname not found'
        if self.isGitBash():
            winpty = self.where_cmd('winpty.exe')
            uname = self.where_cmd('uname.exe')
            stdout,stderr = Popen([winpty, uname,switch],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
            if stderr.strip().lower() == 'stdin is not a tty':
                stdout,stderr = Popen([uname,switch],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
        elif self.isCmd():
            stdout,stderr = Popen([self.shellCmd(),'/c',command],stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        else:
            # Assume /bin/sh as default shell
            uname = self.which_cmd('uname')
            if uname != '':
                stdout,stderr = Popen([uname,switch],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
            else:
                return False, 'uname not found'
        if stderr != "" and not ignoreErr:
            self.msg_error(command, stderr)
            return False, stderr
        else:
            return True, stdout

    def uname_a(self, ignoreErr=True):
        return self.uname('-a', ignoreErr=ignoreErr)

    def uname_m(self, ignoreErr=True):
        return self.uname('-m', ignoreErr=ignoreErr)

class Which(Sh):
    """Class to install and configure package."""

    CLASSNAME = "Which"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 2

    @staticmethod
    def class_version():
        return f"{Which.CLASSNAME} v{Which.MAJOR_VERSION}.{Which.MINOR_VERSION}.{Which.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(Which, self).__init__(fromClass=fromClass, this=this)

    def which(self):
        if self.isCmd()  or self.isGitBash():
            if self.pathexists(self.localInstallPath()):
                return self.localInstallPath()
            elif self.pathexists(self.globalInstallPath(0)):
                return self.globalInstallPath(0)
            elif self.pathexists(self.globalInstallPath(1)):
                return self.globalInstallPath(1)
            elif self.pathexists('C:\\Windows\\System32\\where.exe'):
                return self.where_cmd( self.appName())
        else:
            if self.pathexists(self.localInstallPath()):
                return self.localInstallPath()
            elif self.pathexists(self.globalInstallPath(0)):
                return self.globalInstallPath(0)
            elif self.pathexists(self.globalInstallPath(1)):
                return self.globalInstallPath(1)
            if self.pathexists('/usr/bin/which'):
                return self.which_cmd( self.appName())

    def which_cmd(self, cmd, default=""):
        if cmd is None:
            return ''
        stdout = ''
        original_cmd = cmd
        if "/" in cmd:
            cmd= cmd.split("/")[-1]
        if "\\" in cmd:
            cmd= cmd.split("\\")[-1]
        if self.isCmd():
            return self.where_cmd(cmd)
        elif self.isGitBash():
            result, stdout = self.ignoreError().shell(["/usr/bin/which", cmd])
            return stdout.strip()
        elif self.isLinuxShell():
            if os.path.exists('/usr/bin/which'):
                result, stdout = self.ignoreError().shell(["/usr/bin/which", cmd])
                return stdout.strip()
            elif os.path.exists('/bin/which'):
                result, stdout = self.ignoreError().shell(["/usr/bin/which", cmd])
                return stdout.strip()
            elif os.path.exists('/bin/%s' % cmd):
                return '/bin/%s' % cmd
            elif os.path.exists('/sbin/%s' % cmd):
                return '/sbin/%s' % cmd
            elif os.path.exists('/usr/bin/%s' % cmd):
                return '/usr/bin/%s' % cmd
            elif os.path.exists('/usr/bin/local/%s' % cmd):
                return '/usr/bin/local/%s' % cmd
            elif os.path.exists('/usr/sbin/%s' % cmd):
                return '/usr/sbin/%s' % cmd
            elif os.path.exists('/home/%s/.local/bin/%s' % (self.username(), cmd)):
                return '/home/%s/.local/bin/%s' % (self.username(), cmd)
            elif 'PATH' in os.environ:
                split_path = os.environ['PATH'].split(':')
                for pathlet in split_path:
                    if os.path.exists('%s/%s' % (pathlet, cmd)):
                        return '%s/%s' % (pathlet, cmd)
        if cmd==original_cmd:
            cmd=default
        return cmd

    def where_cmd(self, cmd, default=""):
        stdout = ''
        if len(cmd) > 4:
            if '.' not in cmd and cmd[-4:] != '.exe':
                cmd = cmd + '.exe'
        elif '.' not in cmd:
            cmd = cmd + '.exe'
        original_cmd = cmd
        if "/" in cmd:
            cmd= cmd.split("/")[-1]
        if "\\" in cmd:
            cmd= cmd.split("\\")[-1]
        if self.isLinuxShell():
            return self.which_cmd(cmd)
        path = "C:\\Users\\%s\\AppData\\Local\\Microsoft\\WindowsApps\\%s" % (self.username(), original_cmd)
        if os.path.exists(path):
            cmd = path
        elif os.path.exists('C:\\Windows\\system32\\%s' % original_cmd):
            cmd = 'C:\\Windows\\system32\\%s' % original_cmd
        elif os.path.exists('C:\\Program Files\\Git\\usr\\bin\\%s' % original_cmd):
            cmd = 'C:\\Program Files\\Git\\usr\\bin\\%s' % original_cmd
        elif 'PATH' in os.environ:
            split_path = os.environ['PATH'].split(';')
            for pathlet in split_path:
                if os.path.exists('%s\\%s' % (pathlet, original_cmd)):
                    cmd =  '%s\\%s' % (pathlet, original_cmd)
                    break
        if cmd==original_cmd and original_cmd != 'winpty.exe':
            result, stdout = self.ignoreError().shell("where %s" % cmd)
            cmd == stdout.strip()
        if cmd==original_cmd:
            cmd=default
        return cmd

    def which_journalctl(self):
        return self.which_cmd('journalctl', '/usr/bin/journalctl')

    def which_systemctl(self):
        return self.which_cmd('systemctl','/usr/bin/systemctl')

    def which_uname(self):
        return self.which_cmd('uname', '/usr/bin/uname')

class Shell(OS, Which):

    CLASSNAME = "Shell"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 20

    @staticmethod
    def class_version():
        return f"{Shell.CLASSNAME} v{Shell.MAJOR_VERSION}.{Shell.MINOR_VERSION}.{Shell.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(Shell, self).__init__(fromClass=fromClass, this=this)
        Attr(self, 'sudo_cmd', self.which_cmd('sudo'))

    def msg_permission_denied(self, path="", title=""):
        self.criticalMsg("Permission denied: %s" % path, title)

    def msg_user_found(self, username="", title="CREATING USER"):
        self.infoMsg("Existing user group: %s found." % username, title)

    def msg_user_group_found(self, usergroup="", title="CREATING GROUP"):
        self.infoMsg("Existing user: %s found." % usergroup, title)

    def chdir(self, path, line_num=None):
        if self.isCmd() or self.isGitBash():
            self.history_cd(self.path_to_dos(path), line_num)
            os.chdir(self.path_to_dos(path))
        else:
            self.history_cd(path, line_num)
            os.chdir(path)

    def chmod(self, filePath="", switch="", use_history=True, useSudo=False):
        if self.isCmd() or self.isGitBash():
            filePath=self.path_to_dos(filePath)
        if self.pathexists(filePath):
            chmod_cmd = self.which_cmd('chmod', "")
            cmd=""
            if chmod_cmd != "":
                if useSudo:
                    if self.sudo_cmd()!="":
                        cmd = '%s %s %s %s' % (self.sudo_cmd(), chmod_cmd,switch,filePath)
                else:                
                    cmd = '%s %s %s' % (chmod_cmd,switch,filePath)
                if cmd=="":
                    return False                
                if use_history:
                    self.cmd_history(cmd)
                result, stdout = self.shell(cmd)
            return result
        return False

    def chown(self, filePath="", owner="", use_history=True, useSudo=False):
        if self.isCmd() or self.isGitBash():
            filePath=self.path_to_dos(filePath)
        if self.pathexists(filePath):
            chown = self.which_cmd('chown')
            cmd=""
            if useSudo:
                if self.sudo_cmd()!="":
                    cmd = '%s %s -R %s %s' % (self.sudo_cmd(), chown,owner,filePath)
            else:                
                cmd = '%s -R %s %s' % (chown,owner,filePath)    
            if cmd=="":
                return False            
            if use_history:
                self.cmd_history(cmd)
            result, stdout = self.shell(cmd)
            return result
        return False
    
    def chmod_x(self, filePath="", use_history=True, useSudo=False):
        if self.is_window():
            return False
        return self.chmod(filePath=filePath, switch="+x", use_history=use_history, useSudo=useSudo)

    def comparePath(self, p1, p2):
        return os.path.abspath(p1)==os.path.abspath(p2)

    def cp(self, filePath1="", filePath2="", use_history=True, useSudo=False):
        cmd = ""
        stdout = ""
        if self.isCmd():
            filePath1=self.path_to_dos(filePath1)
            filePath2=self.path_to_dos(filePath2)
            if self.isCmd():
                if "*" in filePath1 or os.path.isdir(filePath1):
                    cmd = 'xcopy %s %s /e /i' % (filePath1,filePath2)
                else:
                    cmd = 'copy %s %s' % (filePath1,filePath2)
        elif self.isGitBash():
            filePath1=self.path_to_gitbash(filePath1)
            filePath2=self.path_to_gitbash(filePath2)
            cmd = 'cp %s %s' % (filePath1,filePath2)
        else:
            cp = self.which_cmd('cp')
            if useSudo:
                cmd = '%s %s -rP %s %s' % (self.sudo_cmd(), cp,filePath1,filePath2)
            else:
                cmd = '%s -rP %s %s' % (cp,filePath1,filePath2)
        if cmd=="":
            return False 
        if use_history:
            self.cmd_history(cmd)
        result, stdout = self.shell(cmd)
        if not result:
            self.hasError()
        return result, stdout

    def create_group(self, groupname=None, user_id=None, group_id=None, useSudo=False):
        cmd= "getent group %s" %  groupname
        self.history_check_group_exists(currentframe().f_lineno)
        self.cmd_history(cmd)
        result, stdout = self.shell(cmd)
        if group_id is None and not (user_id is None):
            group_id = user_id
        if stdout=="":
            cmd = ""
            if self.is_alpine():
                if useSudo:
                    cmd = "sudo addgroup -g %d %s" % (group_id, groupname)
                else:
                    cmd = "addgroup -g %d %s" % (group_id, groupname)
            elif self.is_debian() or self.osVersion().startswith('CentOS') or self.is_fedora():
                if useSudo:
                    cmd = "sudo groupadd -g %d %s" % (group_id, groupname)
                else:
                    cmd = "groupadd -g %d %s" % (group_id, groupname)
            if cmd != "":
                self.history_add_group(groupname, currentframe().f_lineno)
                self.cmd_history(cmd)
                self.ignoreError().shell(cmd)
        else:
            self.history_group_exists(groupname, currentframe().f_lineno)
            self.msg_user_group_found(groupname)

    def create_user(self, username=None, user_id=None, group_id=None, home=None, useSudo=False):
        self.create_group(username, user_id=user_id, group_id=group_id, useSudo=useSudo)
        cmd= "id %s" % username
        self.history_check_user_exists(currentframe().f_lineno)
        self.cmd_history(cmd)
        result, stdout = self.ignoreError().shell(cmd)
        if stdout=="":
            cmd = ""
            if home is None:                    
                if self.is_alpine():
                    if useSudo:
                        cmd = "sudo adduser -D -G %s %s" % (group_id, username)
                    else:
                        cmd = "adduser -D -G %s %s" % (group_id, username)
                elif self.is_debian() or self.osVersion().startswith('CentOS') or self.is_fedora():
                    if useSudo:
                        cmd = "sudo useradd -g %d -u %d -m -s /bin/bash %s" % (group_id, user_id, username)
                    else:
                        cmd = "useradd -g %d -u %d -m -s /bin/bash %s" % (group_id, user_id, username)
            else:
                if self.is_alpine():
                    if useSudo:
                        cmd = "sudo adduser -D -G %s -h %s %s" % (username, home, username)
                    else:
                        cmd = "adduser -D -G %s -h %s %s" % (username, home, username)
                elif self.is_debian() or self.osVersion().startswith('CentOS') or self.is_fedora():
                    if useSudo:
                        cmd = "sudo useradd -g %d -u %d -m -d %s -s /bin/bash %s" % (group_id, user_id, home, username)
                    else:
                        cmd = "useradd -g %d -u %d -m -d %s -s /bin/bash %s" % (group_id, user_id, home, username)
            if cmd != "":
                self.history_add_user(username, currentframe().f_lineno)
                self.cmd_history(cmd)
                self.ignoreError().shell(cmd)
        else:
            self.history_user_exists(username, currentframe().f_lineno)
            self.msg_user_found(username)

    def curPath(self, curPath=None):
        if curPath is not None:
            self.__curPath__=curPath
            return self
        elif not hasattr(self, '__curPath__'):
            pw='%s' % os.getcwd()
            if self.isGitBash() and ':' in pw:
                pw=pw.split(':')
                self.__curPath__='/'+pw[0]+'/'.join(pw[1].split('\\'))
            else:
                self.__curPath__=pw
        return self.__curPath__

    def home(self):
        return os.path.expanduser("~")


    def is_gnu_tar(self):
        result = False
        tar = self.which_cmd("tar")
        if tar != "":
            result, stdout = self.shell([tar,"--version"])
            if "GNU tar" in stdout:
                result = True
        return result

    def mkdir(self, path, useSudo = False):
        if not self.pathexists( path ):
            if self.isCmd():
                path=self.path_to_dos(path)
                dir_split = path.split('\\')
                dirloc = dir_split[0]
                for dirlet in dir_split[1:]:
                    self.cmd_history("md %s" % path)
                    if dirlet != '':
                        dirloc = dirloc + '\\' + dirlet
                        if not self.pathexists(dirloc):
                            os.mkdir( dirloc )
            else:
                if useSudo:
                    self.cmd_history("sudo mkdir -p %s" % path)
                else:
                    self.cmd_history("mkdir -p %s" % path)
                dir_split = path.split('/')
                dirloc = ''
                for dirlet in dir_split:
                    if dirlet != '':
                        dirloc = dirloc + '/' + dirlet
                        if not self.pathexists(dirloc):
                            try:
                                if useSudo:
                                    self.shell("sudo mkdir -p %s" % dirloc)
                                else:
                                    os.mkdir( dirloc )
                            except:
                                self.msg_permission_denied(dirloc)
                                return False
            return True
        return True

    def move(self, src, tarDir, use_history=True, useSudo=False):
        if not os.path.exists(tarDir):
            self.cmd_history(f"# ** Creating folder: {tarDir} **", currentframe().f_lineno)
            self.mkdir(tarDir, useSudo=useSudo)
        self.cmd_history(f"# ** Moving {src} to {tarDir} **", currentframe().f_lineno)
        if useSudo:
            cmd = f"sudo mv {src} {tarDir}"
        else:
            cmd = f"mv {src} {tarDir}"
        self.cmd_history(cmd)
        self.ignoreError().shell(cmd)

    def open(self, fname="", sw="", use_history=True):
        if self.isGitBash() or self.isCmd():
            fname = self.path_to_dos(fname)
        if use_history:
            cmd='# python> open("%s", "%s")' % (fname,sw)
            self.cmd_history(cmd)
        return open(fname, sw)

    def removeFile(self, filePath="", use_history=True, useSudo=False):
        if self.isCmd():
            filePath=self.path_to_dos(filePath)
        elif self.isGitBash():
            filePath=self.path_to_gitbash(filePath)
        if self.pathexists(filePath):
            if self.isCmd():
                filePath=self.path_to_dos(filePath)
                cmd = 'del %s' % filePath
            else:
                rm = self.which_cmd('rm')
                if useSudo:
                    cmd = 'sudo %s %s' % (rm,filePath)
                else:
                    cmd = '%s %s' % (rm,filePath)
            if use_history:              
                self.cmd_history(cmd)
            if self.isCmd():
                os.remove(filePath)
            else:
                self.shell(cmd)

    def removeGlobalInstaller(self):
        file1 = self.globalInstallPath(0)
        file2 = self.globalInstallPath(1)
        display_once = False
        if os.path.exists(file1):
            self.history_remove_previous_global(currentframe().f_lineno)
            display_once = True
            self.sudoRemoveFile(file1)
        if os.path.exists(file2):
            if not display_once:
                self.history_remove_previous_global(currentframe().f_lineno)
                display_once = True
            self.sudoRemoveFile(file2)

    def removeFilePattern(self, dirPath, pattern):
        if self.pathexists(dirPath) and os.path.isdir(dirPath):
            for file in os.listdir(dirPath):
                if file.endswith(pattern):
                    self.removeFile("%s/%s" % (dirPath,file))

    def removeFolder(self, dirPath, use_history=True, useSudo=False):
        if use_history:
            self.history_remove_folder(dirPath)
        if self.isCmd() or self.isGitBash():
            dirPath=self.path_to_dos(dirPath)
        if self.pathexists(dirPath) and os.path.isdir(dirPath):
            if use_history:
                self.cmd_history("rm -rf %s" % dirPath)
            if useSudo:
                rm = self.which_cmd('rm')
                cmd = 'sudo %s -rf %s' % (rm,dirPath)
                self.shell(cmd)
            else:
                shutil.rmtree(dirPath)
        else:
            if use_history:
                self.cmd_history("# folder %s: not found, cannot be removed." % dirPath)

    def remove_user(self, username=None,useSudo=False):
        cmd= "id %s" % username
        self.history_check_user_exists(currentframe().f_lineno)
        self.cmd_history(cmd)
        result, stdout = self.ignoreError().shell(cmd)
        if stdout!="":
            cmd = ""
            if self.is_alpine():
                if useSudo:
                    cmd = "sudo deluser --remove-home %s" % username
                else:
                    cmd = "deluser --remove-home %s" % username
            elif self.is_debian() or self.osVersion().startswith('CentOS'):
                if useSudo:
                    cmd = "sudo userdel -r %s" % username
                else:
                    cmd = "userdel -r %s" % username
            self.history_remove_user(username,currentframe().f_lineno)
            self.cmd_history(cmd)
            self.ignoreError().shell(cmd)

    def shell(self, command='', ignoreErr=False, ignoreShell=False, ignoreAll=False):
        stderr = ''
        stdout = ''
        useWinpty = False
        if ignoreErr:
            self.ignoreError()
        if ignoreAll:
            pipe_array=[]
        elif ignoreShell:
            if self.isGitBash():
                winpty = self.where_cmd('winpty.exe')
                if winpty == "":
                    pipe_array=[]
                else:
                    useWinpty = True
                    pipe_array=[winpty]
            else:
                pipe_array=[]
        elif self.isLinuxShell():   
            pipe_array=[self.shellCmd(),'-c']
        elif self.isGitBash():
            winpty = self.where_cmd('winpty.exe')
            if winpty == "":
                pipe_array=[self.shellCmd(),'-c']
            else:
                useWinpty = True
                pipe_array=[winpty, self.shellCmd(),'-c']
        elif self.isCmd():
            pipe_array=[self.shellCmd(),'/c']
        else:
            # Assume /bin/sh as default shell
            pipe_array=['/bin/sh','-c']
        if isinstance(command, basestring):
            pipe_array.append(command)
        elif isinstance(command, list):
            if self.isCmd() or self.isGitBash():
                for cmdlet in command:
                    pipe_array.append(cmdlet)
            else:
                pipe_array=[]
                for cmdlet in command:
                    pipe_array.append(cmdlet)
        else:
            if self.testIgnoredResetNormal():
                return True, ""
            else:
                self.hasError()
                return False, "Wrong command data type."
        try:
            stdout,stderr = Popen(pipe_array,stdin=PIPE,stdout=PIPE,\
                stderr=PIPE,universal_newlines=True).communicate('\n')
        except:
            if self.testIgnoredResetNormal():
                return True, ""
            else:
                self.hasError()
                return False
        try:
            if stderr.strip().lower() == 'stdin is not a tty' and useWinpty:
                stdout,stderr = Popen(pipe_array[1:],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
            if stderr != "":
                if self.testIgnoredResetNormal():
                    return True, stdout
                else:
                    self.hasError()
                    self.msg_error(command, stderr)
                    return False, stderr
        except:
            if self.testIgnoredResetNormal():
                return True, ""
            else:
                self.hasError()
                return False, ""
        self.resetNormal()
        return True, stdout

    def ln(self, source="", target="", use_history=True, useSudo=False):
        if self.isCmd():
            self.msg_wrong_shell('ln')
            return False
        if self.isGitBash():  
            filePath=self.path_to_dos(source)
        if self.pathexists(source):
            source_split = source.split('/')
            if len(source_split) > 0:
                last_part=source_split[len(source_split) - 1]
                if target[-1] == '/':
                    test_path = '%s%s' % (target,last_part)
                else:
                    test_path = '%s/%s' % (target,last_part)
                if self.pathexists(test_path):
                    self.history_link_exists(test_path, currentframe().f_lineno)
                else:
                    cmd = ""
                    ln_cmd = self.which_cmd('ln')
                    if useSudo:
                        if self.sudo_cmd() != "":
                            cmd = '%s %s -s %s %s' % (self.sudo_cmd(),ln_cmd,source,target)
                    else:                
                        cmd = '%s -s %s %s' % (ln_cmd,source,target)
                    if cmd=="":
                        return False
                    if use_history:
                        self.cmd_history(cmd)
                    result, stdout = self.shell(cmd)
                    return result
        return False

    def sudoRemoveFile(self, filePath, useSudo=False):
        if self.pathexists(filePath):
            cmd = ""
            rm_cmd = self.which_cmd('rm')
            if Sudoer.is_root():
                cmd = '%s -rf %s' % (rm_cmd, filePath)
            elif useSudo or self.sudo_test():
                if self.sudo_cmd() != "":
                    cmd = '%s %s -rf %s' % (self.sudo_cmd(), rm_cmd, filePath)
            if cmd=="" or self.signal == 3:
                return False
            self.cmd_history(cmd)
            self.shell( cmd )
            return True

    def tar_compress(self,fname, path):
        if self.isCmd() or self.isGitBash():
            tar = self.where_cmd('tar.exe')
        else:
            tar = self.which_cmd('tar')
        if self.is_mac() or self.is_window():
            if self.isCmd():
                fname = self.path_to_dos(fname)
            cmd= [tar,"--uid","0","--gid","0", "--no-same-owner","--no-same-permissions","-cvf", fname, path]
        else:
            cmd= [tar,"--owner=0", "--group=0", "--no-same-owner","--no-same-permissions","-cvf", fname, path]
        self.cmd_history(" ".join(cmd))
        result, stdout = self.ignoreError().shell(cmd,ignoreAll=True)

    def tar_extract(self,fname):
        if self.isCmd() or self.isGitBash():
            tar = self.where_cmd('tar.exe')
        else:
            tar = self.which_cmd('tar')
        if self.isCmd():
            fname = self.path_to_dos(fname)        
        cmd= [tar,"-xvf", fname]
        self.cmd_history(" ".join(cmd))
        result, stdout = self.ignoreError().shell(cmd,ignoreAll=True)

class Temp(AppHistory):

    CLASSNAME = "Temp"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 2

    @staticmethod
    def class_version():
        return f"{Temp.CLASSNAME} v{Temp.MAJOR_VERSION}.{Temp.MINOR_VERSION}.{Temp.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(Temp, self).__init__(fromClass=fromClass, this=this)
        # Should call setInstallation before __init_temp__()
        # self.__init_temp__()

    def msg_temp_folder_failed(self, folder="", title=""):
        if not hasattr(self,'__msg_temp_error__'):
            self.__msg_temp_error__=True
            self.criticalMsg("Cannot access or create temp folder: %s" % folder, title)

    def __init_temp__(self):
        Attr(self, "tempFile", "")
        appName = self.appName()
        tempFolder=self.tempFolder()
        if tempFolder=="":
            return False
        if self.isCmd():
            fname="%s\\%s-%s.bat" % (tempFolder, appName,self.timestamp())
        elif self.isGitBash():
            # GitBash download location should remain the same such that starting with /c/Users/user...
            fname="%s\\%s-%s.bat" % (tempFolder, appName,self.timestamp())
        else:
            fname="%s/%s-%s" % (tempFolder, appName,self.timestamp())
        self.tempFile(fname)
        return True

    def tempFolder(self):
        if not hasattr(self,'__temp_checked__'):
            self.__temp_checked__=0
            self.history_check_mkdir(currentframe().f_lineno)
        if "TEMP" in os.environ:
            # in windows, most likely
            folder=os.environ["TEMP"]
        elif self.isGitBash():
            folder="/tmp" 
        elif self.isCmd():
            folder="C:\\Users\\%s\\AppData\\Local\\Temp" % self.username()
        elif self.is_mac():
            folder = '/Users/%s/Library/Caches' % self.username()
        elif self.username() == 'root':
            folder="/tmp" 
        else:
            folder="/home/%s/.local/temp" % self.username()
            self.mkdir(folder)
        if not self.isGitBash():
            if self.__temp_checked__<1:
                if not self.pathexists(folder):
                    if not self.mkdir(folder):
                        return ""
            if self.__temp_checked__==0:
                use_history=True
            else:
                use_history=False
            self.__temp_checked__=self.__temp_checked__+1
            if self.pathexists(folder, use_history=use_history):
                return folder
            self.msg_temp_folder_failed(folder)
            return ""
        else:
            return folder

class InstallerBase(Shell,Temp):

    CLASSNAME = "InstallerBase"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 15

    @staticmethod
    def class_version():
        return f"{InstallerBase.CLASSNAME} v{InstallerBase.MAJOR_VERSION}.{InstallerBase.MINOR_VERSION}.{InstallerBase.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(InstallerBase, self).__init__(fromClass=fromClass, this=this)

    def install_package(self, package=None, path=None):
        installed = False
        self.history_check_exists(package, currentframe().f_lineno)
        if self.which_cmd(package):
            self.cmd_history(f"  # {package} exists")
            return True
        checkPath=False
        if path is not None and package is not None:
            if isinstance(path,basestring):
                if self.pathexists(path, use_history=True):
                    self.history_package_exists(package, currentframe().f_lineno)
                    checkPath= True
                if self.which_cmd(path):
                    self.cmd_history("ls %s" % self.which_cmd(path))
                    checkPath=True
            elif isinstance(path,list):
                for l in path:
                    if self.pathexists(l, use_history=True):
                        self.history_package_exists(package, currentframe().f_lineno)
                        checkPath= True
                    if self.which_cmd(l):
                        self.cmd_history("ls %s" % self.which_cmd(l))
                        self.history_package_exists(package, currentframe().f_lineno)
                        checkPath=True
        if checkPath:
            self.cmd_history(f"  # {package} exists")
            return True
        else:
            self.cmd_history(f"  # {package} not exists")
        if self.update_repository():
            if self.is_debian():
                self.history_install_package(package, currentframe().f_lineno)
                if not Sudoer.is_root():
                    cmd = "sudo apt install -y %s" % package
                else:
                    cmd = "apt install -y %s" % package
                self.cmd_history(cmd)
                result, stdout=self.ignoreError().shell(cmd)
                if 'lock-frontend' in stdout:
                    if not Sudoer.is_root():
                        cmd2 = "sudo rm -rf /var/lib/dpkg/lock-frontend"
                    else:
                        cmd2 = "rm -rf /var/lib/dpkg/lock-frontend"
                    self.cmd_history(cmd2)
                    result, stdout=self.ignoreError().shell(cmd2)
                    self.cmd_history(cmd)
                    result, stdout=self.ignoreError().shell(cmd)
                installed = result
            elif self.is_alpine():
                self.history_install_package(package, currentframe().f_lineno)
                if not Sudoer.is_root():
                    cmd = "sudo apk add %s" % package
                else:
                    cmd = "apk add %s" % package
                self.cmd_history(cmd)
                self.ignoreError().shell(cmd)
                installed = True
            elif self.is_redhat():
                if not Sudoer.is_root():
                    cmd = "sudo yum install -y %s" % package
                else:
                    cmd = "yum install -y %s" % package
                self.cmd_history(cmd)
                self.ignoreError().shell(cmd)
                installed = True
            elif self.is_fedora():
                if not Sudoer.is_root():
                    cmd = "sudo dnf install -y %s" % package
                else:
                    cmd = "dnf install -y %s" % package
                self.cmd_history(cmd)
                self.ignoreError().shell(cmd)
                installed = True
            elif self.is_opensuse():
                if not Sudoer.is_root():
                    cmd = "sudo zypper install -y %s" % package
                else:
                    cmd = "zypper install -y %s" % package
                self.cmd_history(cmd)
                self.ignoreError().shell(cmd)
                installed = True
            else:
                self.cmd_history("  # Not compatible OS")
                self.msg_not_compatible_os()
            if installed:
                if path is not None and package is not None:
                    if isinstance(path,basestring):
                        if self.pathexists(path):
                            installed = True
                    elif isinstance(path,list):
                        for l in path:
                            if self.pathexists(l):
                                installed = True
                else:
                    installed = False
            if installed:
                self.cmd_history(f"  # {package} has just installed")
        return installed

    def installedGlobal(self):
        return self.pathexists(self.globalInstallPath(0)) or self.pathexists(self.globalInstallPath(1)) 

    def installedLocal(self):
        which = self.which()
        if which == '':    
            return False
        if self.isCmd() or self.isGitBash():
            return self.path_to_dos(which) == self.path_to_dos(self.localInstallPath())
        return which == self.localInstallPath()

    def install_target_global(self, this, useSudo=False):
        if self.targetApp() != '':
            file1 = self.globalInstallTargetPath(0)
            file2 = self.globalInstallTargetPath(1)
            self.history_remove_previous_global(currentframe().f_lineno)
            self.sudoRemoveFile( file1 )
            self.sudoRemoveFile( file2 )
        if self.pathexists(self.globalFolder(0)):
            self.history_copy_uncompressed(currentframe().f_lineno)
            self.cp(this,file1,useSudo=useSudo)
            if not self.isCmd() and not self.isGitBash():
                self.history_change_target_mode(currentframe().f_lineno)
                self.chmod_x(file1, useSudo=useSudo)
        elif self.pathexists(self.globalFolder(1)):
            self.history_copy_uncompressed(currentframe().f_lineno)
            self.cp(this,file2,useSudo=useSudo)
            if not self.isCmd() and not self.isGitBash():
                self.history_change_target_mode(currentframe().f_lineno)
                self.chmod_x(file2, useSudo=useSudo)
        if this.startswith('/tmp') or self.isGitBash() or self.isCmd():
            self.history_remove_uncompressed(currentframe().f_lineno)
            self.removeFile(this)

    def install_target_local(self, this):
        self.mkdir( self.localInstallFolder() )
        if self.targetApp() != '':
            self.history_remove_previous_local(currentframe().f_lineno)
            self.removeFile(self.localTargetInstallPath())
        self.history_copy_uncompressed(currentframe().f_lineno)
        self.cp(this, self.localInstallFolder())
        if not self.isCmd() and not self.isGitBash():
            self.history_change_target_mode(currentframe().f_lineno)
            result = self.chmod_x(self.localTargetInstallPath())
        if this.startswith('/tmp') or self.isCmd() or self.isGitBash():
            self.history_remove_downloaded(currentframe().f_lineno)
            self.removeFile(this)
        self.check_env()

    def rc_update(self, package):
        self.history_check_rc_update(currentframe().f_lineno)
        if Sudoer.root_or_sudo("InstallerBase::rc_update"):
            rc_cmd = self.which_cmd("rc-update")
            if rc_cmd != "":
                if self.sudo_cmd!="":
                    cmd = 'sudo %s add %s default' % (rc_cmd, package)
                else:
                    cmd = '%s add %s default' % (rc_cmd, package)

    def update_repository(self):
        # root_or_sudo() Check user is root or has sudo privilege and assuming linux
        cmd = ""
        if not Sudoer.root_or_sudo():
            return False
        if not hasattr(self,'__has_repository_updated__'):
            self.__has_repository_updated__ = False
        if self.__has_repository_updated__:
            return True
        if self.is_debian():
            if Sudoer.is_root():
                cmd = "apt update"
            else:
                cmd = "sudo apt update"
        elif self.is_alpine():
            cmd = "apk update"
        elif self.osVersion().startswith('CentOS'):
            if Sudoer.is_root():
                cmd = "yum check-update"
            else:
                cmd = "sudo yum check-update"
        elif self.is_fedora():
            if Sudoer.is_root():
                cmd = "dnf check-update"
            else:
                cmd = "sudo dnf check-update"
        else:
            self.msg_not_compatible_os()
        if cmd != "":
            self.history_update_repository(currentframe().f_lineno)
            self.cmd_history(cmd)
            self.ignoreError().shell(cmd)
            self.__has_repository_updated__=True
            return True
        return False

    def uninstall_package(self, package=None, path=None):
        # root_or_sudo() Check user is root or has sudo privilege and assuming linux
        if not Sudoer.root_or_sudo("InstallerBase::uninstall_package"):
            return False
        installed = False
        location = ''
        if path is not None and package is not None:
            self.history_check_exists(package, currentframe().f_lineno)
            if isinstance(path,basestring):
                if self.pathexists(path, use_history=True):
                    location = path
                    installed=True
                    self.history_location_found(location, currentframe().f_lineno)
            elif isinstance(path,list):
                for l in path:
                    if self.pathexists(l, use_history=True):
                        location = l
                        installed=True
                        self.history_location_found(location, currentframe().f_lineno)
        if installed:
            if self.is_debian():
                self.history_uninstall_package(package, currentframe().f_lineno)
                if not Sudoer.is_root():
                    cmd = ["sudo", "DEBIAN_FRONTEND=noninteractive", "apt", "purge", "--auto-remove", "-y", package]
                else:
                    cmd =["DEBIAN_FRONTEND=noninteractive", "apt", "purge", "--auto-remove", "-y", package]
                self.cmd_history(" ".join(cmd))
                self.ignoreError().shell(cmd)
                installed = True
            elif self.is_alpine():
                self.history_uninstall_package(package, currentframe().f_lineno)
                if not Sudoer.is_root():
                    cmd = ["sudo", "apk", "del", package]
                else:
                    cmd = ["apk", "del", package]
                self.cmd_history(" ".join(cmd))
                self.ignoreError().shell(cmd)
                installed = True
            elif self.osVersion().startswith('CentOS'):
                if not Sudoer.is_root():
                    cmd = "sudo yum remove -y %s" % package
                else:
                    cmd = "yum remove -y %s" % package
                self.cmd_history(cmd)
                self.ignoreError().shell(cmd)
                installed = True
            elif self.is_fedora():
                if not Sudoer.is_root():
                    cmd = "sudo dnf remove -y %s" % package
                else:
                    cmd = "dnf remove -y %s" % package
                self.cmd_history(cmd)
                self.ignoreError().shell(cmd)
                installed = True
            else:
                self.msg_not_compatible_os()
                return False
            if self.pathexists(location):
                self.msg_uninstall_global()
                return False
        return installed

    def nopw(self, user, cmd):
        return "%s ALL=(ALL) NOPASSWD: %s" % (user, cmd)

    def add_sudoers(self, fname, content):
        # root_or_sudo() Check user is root or has sudo privilege and assuming linux
        if not Sudoer.root_or_sudo("InstallerBase::add_sudoers"):
            return False
        target_sudoers="/etc/sudoers.d/%s" % fname
        if not self.pathexists(target_sudoers):
            tempSudoer = "%s/%s-%s" % (self.tempFolder(),fname, self.timestamp())
            file = self.open(tempSudoer,'w')
            file.write(content)
            file.close()
            if Sudoer.is_root():
                self.cp(tempSudoer, target_sudoers)
            else:
                self.cp(tempSudoer, target_sudoers, useSudo=True)
            self.history_remove_temp(currentframe().f_lineno)
            self.removeFile(tempSudoer)
            return True
        return True

    def __alpine_ask_install_sudo__(self):
        if self.ask_install_sudo():
            cmd=['apk', 'add', 'sudo']
            self.cmd_history(' '.join(cmd))
            result, stdout = self.shell(cmd, True)
            cmd="echo '%wheel ALL=(ALL) ALL' > /etc/sudoers.d/wheel"
            self.cmd_history(cmd)
            result, stdout = self.shell(cmd)
    
    def add_apk_community(self):
        comm="https://dl-cdn.alpinelinux.org/alpine/%s/community" % self.alpine_version()
        hasCommunity=False
        self.history_check_repositories(currentframe().f_lineno)
        fin = self.open('/etc/apk/repositories', "rt", use_history=True)
        for line in fin:
            if 'https://dl-cdn.alpinelinux.org' in line and 'community' in line:
                if '#' not in line:
                    hasCommunity=True
        fin.close()
        if not hasCommunity:
            with self.open('/etc/apk/repositories', "a") as file:
                file.write("\n%s\n" % comm)
            file.close()
        return True

    def msg_uninstall_global(self, title="GLOBAL UNINSTALL"):
        self.safeMsg("You have uninstalled successfully.", title)

    def msg_not_compatible_os(self, title="INSTALL"):
        self.infoMsg("Your OS is not compatible: %s" % self.osVersion(), title)

    def msg_root_continue(self, title="SELF INSTALL"):
        self.infoMsg("You must be root or sudo to continue installation!", title)

class InstallPing(InstallerBase):

    CLASSNAME = "InstallPing"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 3

    @staticmethod
    def class_version():
        return f"{InstallPing.CLASSNAME} v{InstallPing.MAJOR_VERSION}.{InstallPing.MINOR_VERSION}.{InstallPing.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(InstallPing, self).__init__(fromClass=fromClass, this=this)

    def install_ping(self):
        if self.is_alpine():
            result = self.install_package('iputils-ping', ['/usr/bin/ping'])
        else:
            result = self.install_package('iputils-ping', ['/usr/bin/ping'])
        return result

    def uninstall_ping(self):
        if self.is_alpine():
            result = self.uninstall_package('iputils-ping', ['/usr/bin/ping'])
        else:
            result = self.uninstall_package('iputils-ping', ['/usr/bin/ping'])
        return result

class PyCheck(Shell):

    CLASSNAME = "PyCheck"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 4

    @staticmethod
    def class_version():
        return f"{PyCheck.CLASSNAME} v{PyCheck.MAJOR_VERSION}.{PyCheck.MINOR_VERSION}.{PyCheck.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(PyCheck, self).__init__(fromClass=fromClass, this=this)
        Attr(self, "pyChecked", False)
        Attr(self, "cythonString", "")
        Attr(self, "python2", "")
        Attr(self, "python3", "")
        Attr(self, "py2Found", False)
        Attr(self, "py3Found", False)
        self.check_python()
            
    def check_python(self):
        if not self.pyChecked():
            self.cmd_history("# ** Checking python version  **",currentframe().f_lineno)
            if self.is_window():
                python2 = self.where_cmd("python2.exe",default="")
                python3 = self.where_cmd("python3.exe",default="")
            else:
                python2 = self.which_cmd("python2",default="")
                python3 = self.which_cmd("python3",default="")
            arch = 'x86_64'
            if self.arch() == 'amd64':
                arch = 'x86_64'
            else:
                arch=self.arch()
            if python2 == '' or python3 == '':
                python = self.which_cmd("python")
                if python != "":
                    if self.isGitBash():
                        python = self.path_to_gitbash(python)
                    result , stdout = self.ignoreError().shell([python,"--version"])
                    if result:
                        id_array = stdout.strip().split(' ')
                        if len(id_array) > 1:
                            version_array = id_array[1].split(".")
                            version = version_array[0]
                            if int(version) == 2:
                                python2 = python
                            elif int(version) == 3 and python3=='':
                                python3 = python
                            if self.is_mac():
                                self.cythonString("cpython-%s%s-darwin" % (version_array[0], version_array[1]))
                            elif self.arch()=='armv7l':
                                self.cythonString("cpython-%s%s-arm-linux-gnueabihf" % (version_array[0], version_array[1]))
                            else:
                                self.cythonString("cpython-%s%s-%s-linux-gnu" % (version_array[0], version_array[1], arch))
            if self.isGitBash():
                self.python2( self.path_to_gitbash(python2) )
                self.python3( self.path_to_gitbash(python3) )
            else:
                self.python2( python2 )
                self.python3( python3 )
            if python2!="" and not self.py2Found():
                self.py2Found( True )
                self.cmd_history("  # python2 found: %s" % python2)
            if python3!="" and  not self.py3Found():
                self.py3Found( True )
                self.cmd_history("  # python3 found: %s" % python3)
            if self.python2() != "":
                result , stdout = self.ignoreError().shell([self.python2(),"--version"])
                if result:
                    id_array = stdout.strip().split(' ')
                    if len(id_array) > 1:
                        version_array = id_array[1].split(".")
                        if self.is_mac():
                            self.cythonString("cpython-%s%s-darwin" % (version_array[0], version_array[1]))
                        elif self.arch()=='armv7l':
                            self.cythonString("cpython-%s%s-arm-linux-gnueabihf" % (version_array[0], version_array[1]))
                        else:
                            self.cythonString("cpython-%s%s-%s-linux-gnu" % (version_array[0], version_array[1], arch))
            if self.python3() != "":
                result , stdout = self.ignoreError().shell([self.python3(), "--version"])
                if result:
                    id_array = stdout.strip().split(' ')
                    if len(id_array) > 1:
                        version_array = id_array[1].split(".")
                        if self.is_mac():
                            self.cythonString("cpython-%s%s-darwin" % (version_array[0], version_array[1]))
                        elif self.arch()=='armv7l':
                            self.cythonString("cpython-%s%s-arm-linux-gnueabihf" % (version_array[0], version_array[1]))
                        else:
                            self.cythonString("cpython-%s%s-%s-linux-gnu" % (version_array[0], version_array[1], arch))
        self.pyChecked(True)

class CheckSystem(PyCheck):

    CLASSNAME = "CheckSystem"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 12

    @staticmethod
    def class_version():
        return f"{CheckSystem.CLASSNAME} v{CheckSystem.MAJOR_VERSION}.{CheckSystem.MINOR_VERSION}.{CheckSystem.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(CheckSystem, self).__init__(fromClass=fromClass, this=this)
        Attr(self, "targetApp", "")

    def msg_system_check(self, title="CHECK SYSTEM"):
        self.chkSys()
        self.safeMsg("Now checking your operation system!", title)
        self.prn("    Python: %s" % self.pythonVersion())
        self.prn("    C Library: %s" % self.libcVersion())
        self.prn("    Operation System: %s" % self.osVersion())
        self.prn("    Architecture: %s" % self.arch())
        self.prn("    Current User: %s" % self.username())
        self.prn("    Shell: %s" % self.shellCmd())
        if self.selfLocation() != self.executable():
            self.prn("    Python Executable: %s" % self.executable())
        self.prn("    python2 location: %s" % self.python2())
        self.prn("    python3 location: %s" % self.python3())
        self.prn("    conda location: %s" % self.which_cmd('conda', default=""))
        self.prn("    pyenv location: %s" % self.which_cmd('pyenv', default=""))
        self.prn("    Inside docker container: %s" % self.is_docker_container())
        self.prn("    Cython String: %s" % self.cythonString())
        self.prn("    Binary Type: %s" % self.binVer() )
        self.prn("    Location: %s" % self.selfLocation() ) 
        if self.selfLocation() != self.thisFile():
            self.prn("    ThisFile: %s" % self.thisFile() ) 
        self.prn("") 

    def msg_info(self, usage=None):
        if usage is None:
            if self.hasFunc('usage'):
                usage=self.usage()
            else:
                usage="N/A"
        if self.isCmd():
            msg1="%s.bat (%s.%s.%s) by %s on %s" % (self.appName(),self.majorVersion(),self.patchVersion(),\
                self.minorVersion(),self.author(),self.lastUpdate())
        else:
            msg1="%s (%s.%s.%s) by %s on %s" % (self.appName(),self.majorVersion(),self.minorVersion(),\
                self.patchVersion(),self.author(),self.lastUpdate())
        if self.hasFunc('isGlobal') and self.isGlobal():
            app = "You are using the GLOBAL INSTALLED version, location:"
        elif self.hasFunc('isLocal') and self.isLocal():
            app = "You are using the LOCAL INSTALLED version, location:"
        else :
            app = "You are using an UNINSTALLED version, location:" 
        python_exe = self.executable()
        if python_exe == '':
            python_exe = self.pyName()

        if self.downloadUrl()=='':
            msg = [
                msg1, 
                '',
                '%s' % app,
                '    %s' % self.selfLocation(),
                '', 
                "Basic Usage:",
                "    %s" % usage,
                '',
                'Please visit our homepage: ',
                '    "%s"' % self.homepage(),
                '',
                '',
                '',
                ''
            ]
        else:
            msg = [
                msg1, 
                '',
                '%s' % app,
                '    %s' % self.selfLocation(),
                '', 
                "Basic Usage:",
                "    %s" % usage,
                '',
                'Please visit our homepage: ',
                '    "%s"' % self.homepage(),
                '',
                'Installation command:',
                '    curl -fsSL %s | %s' % (self.downloadUrl(), python_exe),
                ''
            ]
        starLine=[]
        space=[]
        spaces=[[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
        if self.targetApp() != '':
            spaces.append([])
            spaces.append([])
            msg.append('Target Application:')
            if self.isCmd() or self.isGitBash():
                file3 = self.localTargetInstallPath()
                if self.pathexists(file3):
                    msg.append('    %s' % file3)
                    spaces.append([])
            else:
                file1 = "%s/%s" % (self.globalFolder(0), self.targetApp())
                file2 = "%s/%s" % (self.globalFolder(1), self.targetApp())
                file3 = self.localTargetInstallPath()
                if self.pathexists(file1):
                    msg.append('    %s' % file1)
                    spaces.append([])
                if self.pathexists(file2):
                    msg.append('    %s' % file2)
                    spaces.append([])
                if self.pathexists(file3):
                    msg.append('    %s' % file3)
                    spaces.append([])
            msg.append('')
        maxLen=len(msg[0])
        if self.downloadUrl() == '':
            if self.homepage() == '':
                max_line = len(spaces) - 3
            else:
                max_line = len(spaces) - 2
        else:
            max_line = len(spaces) - 1
        for n in range(1, max_line):
            if len(msg[n]) > maxLen :
                maxLen=len(msg[n])
        for n in range(0, max_line):
            for i in range(1,maxLen - len(msg[n]) + 1):
                spaces[n].append(' ')
            msg[n]=msg[n] + ''.join(spaces[n])
        for i in range(1,maxLen + 5):
            starLine.append("*")
        for i in range(1,maxLen + 1):
            space.append(" ")
        self.prn(''.join(starLine))
        self.prn('* %s *' % ''.join(space))
        for n in range(0, max_line):
            self.prn('* %s *' % msg[n])
        self.prn('* %s *' % ''.join(space))
        self.prn(''.join(starLine))

    def executable(self):
        if hasattr(self, '__executable__'): 
            return self.__executable__
        if '/' in sys.executable:
            self.__executable__  = sys.executable.split('/')[-1]
        elif '\\'  in sys.executable:
            self.__executable__  = sys.executable.split('\\')[-1]
        else:
            self.__executable__ = ''
        return self.__executable__ 

    def localTargetInstallPath(self):
        if self.isCmd() or self.isGitBash():
            return '%s\\%s.exe' % (self.localInstallFolder(), self.targetApp())
        else:
            return os.path.abspath('%s/%s' % (self.localInstallFolder(), self.targetApp()))

    def globalInstallPath(self, id=1):
        folder = self.globalFolder(id)
        if folder[-1] == '/':
            return '%s%s' % (folder, self.appName())
        else:
            return '%s/%s' % (folder, self.appName())

    def isGlobal(self):
        if not hasattr(self,'__is_global__'):
            if self.thisFile().endswith(".so"):
                this=self.this() 
            else:
                this=self.thisFile() 
            if this=='' or this=='<stdin>':
                if self.pathexists(self.globalInstallPath(0)) or self.pathexists(self.globalInstallPath(1)):
                    return True 
                else:
                    return False
            else:
                self.__is_global__ = this== self.globalInstallPath(0) or this == self.globalInstallPath(1)
        return self.__is_global__

    def isLocal(self):
        if not hasattr(self, '__isLocal__'):
            if self.thisFile().endswith(".so"):
                self.__isLocal__=self.this() == self.localInstallPath()
            else:
                self.__isLocal__=self.thisFile() == self.localInstallPath()
        return self.__isLocal__

    def localInstallFolder(self):
        if self.isCmd() or self.isGitBash():
            return 'C:\\Users\\%s\\AppData\\Local\\Microsoft\\WindowsApps' % self.username()
        else:  
            return os.path.abspath('%s/.local/bin' % self.home())

    def localInstallPath(self):
        if self.isCmd() or self.isGitBash():
            return '%s\\%s.bat' % (self.localInstallFolder(), self.appName())
        else:
            return os.path.abspath('%s/%s' % (self.localInstallFolder(), self.appName()))

    def selfLocation(self):
        if self.this() != '' and self.this() != '<stdin>' and self.this() != 'built-in':
            return self.this()
        if getIpythonExists:
            try:
                shell = get_ipython().__class__.__name__
                if shell == 'ZMQInteractiveShell':
                    return "Jupyter"
                elif shell == 'TerminalInteractiveShell':
                    return "IPython"
            except NameError:
                return "Unknown location" 
        exec = sys.executable
        if exec.endswith('python') or exec.endswith('python2') or exec.endswith('python3'):
            return 'Inside Python Intrepreter'
        if 'PATH' in os.environ:
            for p in os.environ['PATH']:
                file = os.path.join(p, exec)
                if os.path.exists(file):
                    self.thisFile(file)
                    return file
        return "Unknown location"

class AppPara(CheckSystem):

    CLASSNAME = "AppPara"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 8

    @staticmethod
    def class_version():
        return f"{AppPara.CLASSNAME} v{AppPara.MAJOR_VERSION}.{AppPara.MINOR_VERSION}.{AppPara.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(AppPara, self).__init__(fromClass=fromClass, this=this)
        Attr(self, "cmd", "")
        Attr(self, "allowSelfInstall", True)
        Attr(self, "allowLinuxOnly", False)
        Attr(self, "allowDisplayInfo", True)
        Attr(self, "allowInstallLocal", True)

class ShellProfile(Shell):

    CLASSNAME = "ShellProfile"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 1

    @staticmethod
    def class_version():
        return f"{ShellProfile.CLASSNAME} v{ShellProfile.MAJOR_VERSION}.{ShellProfile.MINOR_VERSION}.{ShellProfile.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(ShellProfile, self).__init__(fromClass=fromClass, this=this)

    def check_env(self):
        if self.shellCmd() == '/bin/zsh':
            self.history_check_zsh(currentframe().f_lineno)
            self.check_and_modify_zshenv()
        elif self.shellCmd() == '/bin/bash':
            self.history_check_bash(currentframe().f_lineno)
            self.check_and_modify_bashrc()
        elif self.shellCmd() == '/bin/ash':
            self.history_check_ash(currentframe().f_lineno)
            self.check_and_modify_bashprofile()

    def add_bashprofile_modification(self):
        # Append the modification lines to .bashrc file
        modification_lines = [
            "# modified to add ~/.local/bin to PATH",
            "PATH=$PATH:~/.local/bin\n"
        ]
        
        with self.open(self.bashprofile(), "a") as file:
            file.write("\n".join(modification_lines))
        self.chmod_x(self.bashprofile())

    def add_bashrc_modification(self):
        # Append the modification lines to .bashrc file
        modification_lines = [
            "# modified to add ~/.local/bin to PATH",
            "PATH=$PATH:~/.local/bin\n"
        ]
        
        with self.open(self.bashrc(), "a") as file:
            file.write("\n".join(modification_lines))
        self.chmod_x(self.bashrc())

    def add_zshenv_modification(self):
        # Append the modification lines to .bashrc file
        modification_lines = [
            "\n# modified to add ~/.local/bin to PATH",
            "path+=('%s')" %  os.path.join(self.home(), ".local/bin"),
            "export PATH\n"
        ]
        with self.open(self.zshenv(), "a") as file:
            file.write("\n".join(modification_lines))

    def bashprofile(self):
        return os.path.join(self.home(), ".profile")

    def bashrc(self):
        if self.shellCmd() == '/bin/ash':
            return os.path.join(self.home(), ".profile")
        return os.path.join(self.home(), ".bashrc")

    def check_and_modify_bashprofile(self):
        if not self.is_bashprofile_modified():
            self.add_bashprofile_modification()

    def check_and_modify_bashrc(self):
        if not self.is_bashrc_modified():
            self.add_bashrc_modification()

    def check_and_modify_zshenv(self):
        if not self.is_zshenv_modified():
            self.add_zshenv_modification()

    def is_bashprofile_modified(self):
        # Check if .bashrc file exists and if it contains the modification lines
        if not os.path.isfile(self.bashrc()):
            return False
        with self.open(self.bashrc(), "r") as file:
            contents = file.read()
        return "# modified to add ~/.local/bin to PATH" in contents

    def is_bashrc_modified(self):
        # Check if .bashrc file exists and if it contains the modification lines
        if not os.path.isfile(self.bashrc()):
            return False
        with self.open(self.bashrc(), "r") as file:
            contents = file.read()
        return "# modified to add ~/.local/bin to PATH" in contents

    def is_zshenv_modified(self):
        # Check if .zshenv file exists and if it contains the modification lines
        if not os.path.isfile(self.zshenv()):
            return False
        
        with self.open(self.zshenv(), "r") as file:
            contents = file.read()
        
        return "# modified to add ~/.local/bin to PATH" in contents

    def zshenv(self):
        return os.path.join(self.home(), ".zshenv")

class Curl(Shell):

    CLASSNAME = "Curl"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 6

    @staticmethod
    def class_version():
        return f"{Curl.CLASSNAME} v{Curl.MAJOR_VERSION}.{Curl.MINOR_VERSION}.{Curl.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(Curl, self).__init__(fromClass=fromClass, this=this)
        self.networkCore = NetworkCore()

    def msg_downloading(self, url="", title="DOWNLOAD FILES"):
        self.infoMsg("Downloading: %s ..." % url, title)

    def msg_error(self, command="", stderr="", title="ERROR"):
        self.criticalMsg("Error in %s: %s" % (command, stderr), title)

    def msg_timeout(self, file="", title="ERROR"):
        self.criticalMsg("Time out in downloading %s" % (file), title)

    def msg_download_url_error(self, url, code):
        if not hasattr(self,'__msgshown_download_error__'):
            self.criticalMsg("Url: %s\n  HTTP code: %s" % (url, code), "DOWNLOAD ERROR")
            self.__msgshown_download_error__=True

    def curl_cmd(self, url='', file='', switches='-fsSL',  ignoreErr=True):
        stderr = 'Unknown Error'
        stdout = ''
        if self.isLinuxShell():
            curl = self.which_cmd('curl')
            if self.networkCore.check_online():
                if url!='' and file!='':
                    cmd = ' '.join([curl,switches,'-o',file, url])
                    self.cmd_history(cmd)
                    stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                        stderr=PIPE,universal_newlines=True).communicate('\n')
                elif url!='':
                    cmd = ' '.join([curl,switches,url])
                    self.cmd_history(cmd)
                    stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                        stderr=PIPE,universal_newlines=True).communicate('\n')
            else:
                return False, 'Not Online!'
        elif self.isGitBash():
            winpty = self.where_cmd('winpty.exe')
            curl = self.where_cmd('curl.exe')
            if url!='' and file!='':
                file=self.path_to_dos(file)
                cmd = ' '.join([winpty,curl,switches,'-o',file, url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([winpty,curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
                if stderr.strip().lower() == 'stdin is not a tty':
                    cmd = ' '.join([curl,switches,'-o',file, url])
                    self.cmd_history(cmd)
                    stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                        stderr=PIPE,universal_newlines=True).communicate('\n')
            elif url!='':
                cmd = ' '.join([winpty,curl,switches, url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([winpty,curl,switches,url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
                if stderr.strip().lower() == 'stdin is not a tty':
                    cmd = ' '.join([curl,switches, url])
                    self.cmd_history(cmd)
                    stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                        stderr=PIPE,universal_newlines=True).communicate('\n')
        elif self.isCmd():
            curl = self.where_cmd('curl.exe')
            if url!='' and file!='':
                cmd = ' '.join([curl,switches,'-o',file, url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
            elif url!='':
                cmd = ' '.join([curl,switches,url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
        elif url!='':
            # Assume /bin/sh as default shell
            curl = self.which_cmd('curl')
            if url!='' and file!='':
                cmd = ' '.join([curl,switches,'-o',file, url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([curl,switches,'-o',file, url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
            elif url!='':
                cmd = ' '.join([curl,switches,url])
                self.cmd_history(cmd)
                stdout,stderr = Popen([curl,switches,url],stdin=PIPE,stdout=PIPE,\
                    stderr=PIPE,universal_newlines=True).communicate('\n')
        if stderr != "" and not ignoreErr:
            self.msg_error(cmd, stderr)
            return False, stderr
        return True, stdout

    def curl_download(self, url='', file='', ignoreErr=True):
        if self.networkCore.check_online():
            print("is online")
            self.history_curl_check(currentframe().f_lineno)
            if self.curl_is_200(url):
                print("is 200")
                self.history_curl_download(currentframe().f_lineno)
                self.curl_cmd(url=url, file=file, ignoreErr=ignoreErr)
                if file == '':
                    return True
                if file !='' and not self.pathexists(file):
                    count=20
                    # In gitbash, downloading time may be longer
                    self.msg_downloading(file)
                    while count>0 and  not self.pathexists(file):
                        count = count - 1
                        time.sleep(1) # wait for curl download the file
                if file !='' and self.pathexists(file):
                    return True
                elif ignoreErr:
                    return True
                else:
                    self.msg_timeout(file)
                    return False
        return False

    def curl_is_200(self, url):
        result, stdout = self.curl_cmd(url=url, switches='-fsSLI', ignoreErr=True)
        if result:
            result = False
            for rawline in stdout.splitlines():
                line = rawline.strip()
                if 'HTTP' in line.strip():
                    line_split=line.split(' ')
                    if len(line_split) > 1:
                        if  '200' == line_split[1] or '301' == line_split[1] or '302' == line_split[1]:
                            return True
                        else:
                            self.msg_download_url_error(url, line_split[1])
                            return False
        return result

class AppBase(AppPara, ShellProfile, Curl, Temp, Ask):
    CLASSNAME = "AppBase"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 31

    @staticmethod
    def class_version():
        return f"{AppBase.CLASSNAME} v{AppBase.MAJOR_VERSION}.{AppBase.MINOR_VERSION}.{AppBase.PATCH_VERSION}"

    def __init__(self, fromClass=None, this=None):
        self.__init_signal__()
        try:
            super().__init__(fromClass=fromClass, this=this)
        except:
            super(AppBase, self).__init__(fromClass=fromClass, this=this)
        if this is not None:
            self.this(this)
        else:
            self.this(__file__)
        Attr(self, "subCmd", ["check-version","info","install","uninstall"])

    def msg_both_local_global(self, title="INSTALLED TWICE"):
        self.criticalMsg("It may causes error if you have installed both local version and Global Version!\n  Please uninstall local version by,\n    %s uninstall" % self.appPath(), title)

    def msg_downloaded(self, fname="", title="DOWNLOADED"):
        self.safeMsg("File downloaded to: %s" % fname, title)

    def msg_download_not_found(self, file):
        self.criticalMsg("Downloaded File: %s" % file, "NOT FOUND")

    def msg_download_error(self, file):
        if not hasattr(self,'__msgshown_download_error__'):
            self.criticalMsg("Download file error: %s" % file, "DOWNLOAD ERROR")
            self.__msgshown_download_error__=True

    def msg_extraction_error(self, file="", title="DOWNLOAD ERROR"):
        self.criticalMsg("File Extraction error: %s not found" % file, title)

    def msg_global_already(self, title="SELF INSTALL"):
        self.infoMsg("Global installed already!", title)

    def msg_install(self, location="", app="", title="INSTALL"):
        startSh =  ""   # for ash, cmd, gitbash
        if location == 'Locally':
            if self.is_mac():
                startSh = "  Please type 'hash -r' and 'source ~/.zshenv' to refresh zsh shell hash!\n  Then, you can "
            elif self.shellCmd() != '/bin/ash' and self.isLinuxShell():
                startSh =  "  Please type 'hash -r' and 'source ~/.bashrc' to refresh bash shell hash!\n  Then, you can "
            self.safeMsg("Installed %s! \n%s  type '%s' to run!" % (location, startSh, app), title)
        else:
            self.safeMsg("Installed %s! \n    type '%s' to run!" % (location, app), title)

    def msg_installation_failed(self, title="INSTALLATION"):
        self.criticalMsg("Installation failed!", title)

    def msg_latest_available(self, title="CHECK UPDATE"):
        self.infoMsg("Latest Version = %s\n  Update is available" % self.latest_version(), title)

    def msg_linux_only(self):
        self.criticalMsg("This programs required linux only.", "LINUX ONLY")

    def msg_latest(self, title="CHECK VERSION"):
        if self.isLocal():
            self.msg_latest_global(title)
        elif self.isLocal():
            self.msg_latest_local(title)
        else:
            self.infoMsg("You are using latest (%s.%s) already!" % (self.majorVersion(),self.minorVersion()), title)

    def msg_latest_global(self, title="CHECK VERSION"):
        self.infoMsg("You are using latest (%s.%s) Global Installation's copy already!" % (self.majorVersion(),self.minorVersion()), title)

    def msg_latest_local(self, title="CHECK VERSION"):
        self.infoMsg("You are using latest (%s.%s) Local Installation's copy already!" % (self.majorVersion(),self.minorVersion()), title)

    def msg_install_target_global(self, title="INSTALL"):
        if self.isCmd() or self.isGitBash():
            self.msg_install(location='Globally', app="%s.exe" % self.targetApp(), title=title)
        else:
            self.msg_install(location='Globally', app=self.targetApp(), title=title)

    def msg_install_target_local(self, title="INSTALL"):
        if self.isCmd() or self.isGitBash():
            self.msg_install(location='Locally', app="%s.exe" % self.targetApp(), title=title)
        else:
            self.msg_install(location='Locally', app=self.targetApp(), title=title)

    def msg_install_app_global(self, title="INSTALL"):
        if self.isCmd() or self.isGitBash():
            self.msg_install(location='Globally', app="%s.bat" % self.appName(), title=title)
        else:
            self.msg_install(location='Globally', app=self.appName(), title=title)

    def msg_install_app_local(self, title="INSTALL"):
        if self.isCmd() or self.isGitBash():
            self.msg_install(location='Locally', app="%s.bat" % self.appName(), title=title)
        else:
            self.msg_install(location='Locally', app=self.appName(), title=title)

    def msg_no_server(self, title="CONNECTION FAILED"):
        self.criticalMsg("Cannot communicate with server", title)

    def msg_no_global(self, title="GLOBAL UNINSTALL"):
        self.infoMsg("You don't have any global installation.", title)

    def msg_sudo(self, title="SUDO TEST"):
        if not hasattr(self,'__msg_sudo_verified__'):
            self.__msg_sudo_verified__ = True
            self.infoMsg("Your sudo privilege has been verified.", title)

    def msg_unintall_need_root(self, title="GLOBAL UNINSTALL"):
        self.criticalMsg("You should be root or sudo to uninstall globally.", title)

    def msg_uninstall_global(self, title="GLOBAL UNINSTALL"):
        self.safeMsg("You have uninstalled successfully.", title)

    def msg_global_failed(self, title="SELF UNINSTALL"):
        self.criticalMsg("Global uninstall failed!", title)

    def appExec(self):
        if not hasattr(self, '__app_path__'):
            self.appPath()
        if not hasattr(self, '__app_exec__'):
            self.__app_exec__ = ''
            if self.isLocal() or self.isGlobal():
                if self.isCmd() or self.isGitBash():
                    self.__app_exec__ = self.appName() + '.bat'
                else:
                    self.__app_exec__ = self.appName()
            elif self.appPath() != '' :
                if self.isCmd() or self.isGitBash():
                    self.__app_exec__ = self.appName() + '.bat'
                elif self.isLinuxShell():
                    self.__app_exec__='./' + self.appName()
                else:
                    self.__app_exec__='./' + self.appName()
        return self.__app_exec__

    def check_system_and_user(self):
        # is_linux() Check if not windows and not macOS
        if self.allowLinuxOnly() and not self.is_linux():
            self.msg_linux_only()
            return False
        else:
            # root_or_sudo() Check user is root or has sudo privilege
            return Sudoer.root_or_sudo()

    def check_update(self):
        if self.need_update():
            self.msg_latest_available()
        elif self.latest_version() != '0.0':
            self.msg_latest()

    def download_to_temp(self, url=None, file=None, verbal = False):
        if self.tempFolder() == "":
            return False
        if url is None:
            url=self.downloadUrl()
        if file is None:
            file=self.tempFile()
        result = self.curl_download(url=url, file=file)
        if not self.pathexists(file):
            result = False
            self.msg_download_error(file)
        elif verbal:
            self.msg_downloaded(file)
        return result

    def download_and_install(self, verbal = False):
        if self.tempFolder() == "":
            return False

        fname = self.tempFile()
        self.download_to_temp(verbal=False)
        if self.pathexists(fname):
            if not self.install(this=fname, verbal=False):
                return False
        else:
            self.msg_download_not_found(fname)

        if self.targetApp() != '':
            if self.username() == 'root' or  not self.isGlobal():
                result = self.download_and_install_target()
            else:
                self.msg_global_already()
                return False                
        else:
            result=True
        if result:
            if verbal:
                if result:
                    if self.targetApp() != '':
                        if self.username() == 'root':
                            self.msg_install_target_global()
                        else:
                            self.msg_install_target_local()
                    else:
                        if self.username() == 'root':
                            self.msg_install_app_global()
                        else:
                            self.msg_install_app_local()
                else:
                    self.cmd_history_print(currentframe().f_lineno)
            return result
        else:
            self.msg_installation_failed()
        return False

    def download_get_install_pip(self):
        self.tempFile('get-pip')
        self.download_to_temp("https://bootstrap.pypa.io/get-pip.py", file=self.tempFile(), verbal=False)
        cmd="%s %s" % (self.executable(),self.tempFile())
        if (not self.is_mac() and self.is_linux()) and not Sudoer.root_or_sudo():
            cmd="sudo %s %s" % (self.executable(),self.tempFile())
        self.cmd_history("# ** install pip by get-pip.py **", currentframe().f_lineno)
        self.cmd_history(cmd)
        self.ignoreError().shell(cmd)

    def download_and_install_target(self):
        tempFolder = self.tempFolder()
        if self.targetApp() == '' or tempFolder=="":
            return False
        fname = self.tempTargetGzip()
        self.download_to_temp(url=self.tempAppUrl(), file=fname, verbal=False)
        if self.pathexists(fname):
            self.history_cd_decompress(currentframe().f_lineno)
            self.chdir(tempFolder, currentframe().f_lineno)
            if self.isCmd() or self.isGitBash():
                self.tar_extract( self.path_to_dos(fname).split('\\')[-1] )
            else:
                self.tar_extract(fname.split('/')[-1])
            self.history_remove_downloaded(currentframe().f_lineno)
            self.removeFile(fname)
            if self.isCmd() or self.isGitBash():
                this = "%s.exe" % self.tempAttachDecomp()
            else:
                this = self.tempAttachDecomp()
            if self.pathexists(this):
                self.this(this)
                if self.username() == 'root':
                    self.install_target_global(this, useSudo=False)
                else:
                    self.install_target_local(this)
                return True
            else:
                self.cmd_history_print(currentframe().f_lineno)
                self.msg_extraction_error(this)
                return False
        else:
            self.msg_download_error(self.tempTargetGzip())
            return False

    def duplication_warning(self):
        if self.installedLocal() and self.installedGlobal():
            self.msg_both_local_global()

    def findConfig(self, config_path='.', ini_name='cy-master.ini'):
        if config_path != '.':
            configFile = "%s/%s" % (config_path, ini_name) 
            if self.pathexists( configFile ) :
                self.configFile( configFile )
                return True
        pathToken = os.path.abspath(config_path).split('/')
        path = "/".join(pathToken)
        self.configFile( "" )
        while len(pathToken) > 0:
            path = "/".join(pathToken)
            pathToken.pop()
            if path == '' :
                configFile = "/%s" % ini_name
            else :
                configFile = "%s/%s" % (path, ini_name) 
            if self.pathexists( configFile ) :
                self.infoMsg("Configuation file: '%s' !" % configFile, "CONFIG FOUND")
                self.configFile( configFile )
                if config_path == '.':
                    self.projectPath( path )
                return True
        return False

    def globalInstallTargetPath(self, id=1):
        if self.targetApp() == '':
            return ''
        folder = self.globalFolder(id)
        if folder[-1] == '/':
            return '%s%s' % (folder, self.targetApp())
        else:
            return '%s/%s' % (folder, self.targetApp())

    def hasGlobalInstallation(self):
        return  self.pathexists(self.globalInstallPath(0)) or self.pathexists(self.globalInstallPath(1)) 

    def isInstalledGlobal(self):
        return self.pathexists(self.globalInstallPath(0)) or self.pathexists(self.globalInstallPath(1))

    def isInstalledLocal(self):
        return self.pathexists(self.localInstallPath())

    def is_latest(self, major1, major2, minor1, minor2, patch1=0, patch2=0):
        # check 1 is latest, 2 as reference
        return major1>major2 or (major1==major2 and minor1>minor2) or (major1==major2 and minor1==minor2 and patch1>patch2)

    def latest_version(self):
        useRequest = False
        try:
            if not hasattr(self,'__latest_version__'):
                majorVersion = 0
                minorVersion = 0
                lines = []
                result, stdout = self.curl_cmd( url=self.downloadUrl())
                if result:
                    lines = stdout.splitlines()
                for line in lines:
                    if 'setInstallation' in line and self.appName() in line:
                        for token in line.split(')')[0].split(','):
                            if 'majorVersion' in token:
                                majorVersion = int(token.split('=')[1])
                            if 'minorVersion' in token:
                                minorVersion = int(token.split('=')[1])
                self.__latest_version__="%d.%d" % (majorVersion,minorVersion)
                self.__need_update__=self.is_latest(majorVersion, self.majorVersion(), minorVersion, self.minorVersion())
        except:
            self.msg_no_server()
        if not hasattr(self,'__latest_version__'):
            self.__latest_version__='0.0'
        return self.__latest_version__

    def local(self):
        return socket.gethostname()

    def need_update(self):
        if not hasattr(self,'__need_update__'):
            self.__need_update__=False
            self.latest_version()
        return self.__need_update__

    def path_to_dos(self, path):
        # Avoid doing any os.path.realpath conversion
        split_path=path.split('/')
        count=0
        result=''
        for pathlet in split_path:
            # Avoid repeatively adding c:, it should not been there
            if pathlet!= '' and pathlet[-1] != ':':
                count = count + 1
                if count == 1:
                    if len(pathlet) == 1:
                        result = pathlet + ':'
                    else:
                        result = pathlet
                else:
                    result = result + '\\' + pathlet
        return result

    def path_to_gitbash(self, path):
        # Avoid doing any os.path.realpath conversion
        split_path=path.replace("/","\\").split('\\')
        count=0
        result=''
        for pathlet in split_path:
            if pathlet!= '':
                if pathlet[-1] == ':':
                    pathlet=pathlet[:-1]
                result = result + '/' + pathlet
        return result

    def real_path(self, x, curr_path=None):
        if curr_path is None:
            curr_path = self.curPath()
        if self.isCmd():
            if x[:1].startswith(':\\'):
                result=x
            elif x.startswith('..\\'):
                curr_path= '\\'.join(curr_path.split('\\')[:-1])
                if curr_path=='':
                    curr_path=self.curPath()
            result=self.path_to_dos('%s\\%s'% (os.getcwd(),x))
        else:
            if x.startswith('/'):
                result=x
            elif x.startswith('../../'):
                x=x[6:]
                curr_path = '/'.join(curr_path.split('/')[:-2])
            elif x.startswith('../'):
                x=x[3:]
                curr_path = '/'.join(curr_path.split('/')[:-1])
            result='%s/%s' % (curr_path,x)
        return result

    def remove_nginx_adm_sudoer(self, usr="nginx-adm"):
        self.history_remove_sudoer(currentframe().f_lineno)
        target_sudoers="/etc/sudoers.d/1700-%s" % usr
        self.cmd_history("ls %s" % target_sudoers)
        if self.pathexists(target_sudoers):
            self.sudoRemoveFile(target_sudoers)

    def selfUninstallGlobal(self, verbal = True):
        if self.installedGlobal():
            result = False
            display_once = False
            if self.username() != 'root':
                if self.sudo_test():
                    self.msg_sudo()
                    if self.targetApp() != '':
                        file1 = "%s/%s" % (self.globalFolder(0), self.targetApp())
                        file2 = "%s/%s" % (self.globalFolder(1), self.targetApp())
                        if os.path.exists(file1):
                            self.history_remove_previous_global(currentframe().f_lineno)
                            display_once = True
                            self.sudoRemoveFile(file1)
                        if os.path.exists(file1):
                            if not display_once:
                                self.history_remove_previous_global(currentframe().f_lineno)
                                display_once = True
                            self.sudoRemoveFile(file2)
                    if os.path.exists(self.globalInstallPath(0)):
                        if not display_once:
                            self.history_remove_previous_global(currentframe().f_lineno)
                            display_once = True
                        self.sudoRemoveFile(self.globalInstallPath(0))
                        result = True
                    if os.path.exists(self.globalInstallPath(1)):
                        if not display_once:
                            self.history_remove_previous_global(currentframe().f_lineno)
                            display_once = True
                        self.sudoRemoveFile(self.globalInstallPath(1))
                        result = True
                else:
                    if verbal and self.signal() != 2:
                        self.msg_unintall_need_root()
                    return False
            else:
                if self.targetApp() != '':
                    file1 = "%s/%s" % (self.globalFolder(0), self.targetApp())
                    file2 = "%s/%s" % (self.globalFolder(1), self.targetApp())
                    if os.path.exists(file1):
                        self.history_remove_previous_global(currentframe().f_lineno)
                        display_once = True
                        self.sudoRemoveFile(file1)
                    if os.path.exists(file1):
                        if not display_once:
                            self.history_remove_previous_global(currentframe().f_lineno)
                            display_once = True
                        self.sudoRemoveFile(file2)
                if os.path.exists(self.globalInstallPath(0)):
                    if not display_once:
                        self.history_remove_previous_global(currentframe().f_lineno)
                        display_once = True
                    self.sudoRemoveFile(self.globalInstallPath(0))
                    result = True
                if os.path.exists(self.globalInstallPath(1)):
                    if not display_once:
                        self.history_remove_previous_global(currentframe().f_lineno)
                        display_once = True
                    self.sudoRemoveFile(self.globalInstallPath(1))
                    result = True
            if result:
                if verbal:
                    if self.errorState.state == "error":
                        self.cmd_history_print(currentframe().f_lineno)
                    self.msg_uninstall_global()
            else:
                self.msg_global_failed()
            return result
        else:
            self.msg_no_global()
        return False

    def selfUninstall(self, verbal=False):
        once =False
        if self.installedLocal():
            self.selfUninstallLocal(verbal)
            once = True
        if self.installedGlobal():
            if once:
                self.selfUninstallGlobal(verbal=False)
            else:
                self.selfUninstallGlobal(verbal)
            once = True
        if not once:
            self.msg_no_installation()    

    def selfUninstallLocal(self, verbal = True):
        if self.installedLocal():
            self.history_remove_previous_local(currentframe().f_lineno)
            self.removeFile(self.localInstallPath())
            if not os.path.exists(self.localInstallPath()):
                if self.targetApp() != '':
                    self.removeFile(self.localTargetInstallPath())
                if verbal:
                    if self.errorState.state() == "error":
                        self.cmd_history_print(currentframe().f_lineno)
                    self.msg_uninstall_local()
                return True
            else:
                self.msg_no_install_local()
                return False
        else:
            self.msg_no_local()
            return False

    def setInstallation(self,appName='',author='',lastUpdate='',homepage='',downloadUrl="",majorVersion=0,minorVersion=0,patchVersion=0):
        self.author( author ) \
            .appName( appName ) \
            .downloadUrl( downloadUrl ) \
            .homepage( homepage ) \
            .lastUpdate( lastUpdate ) \
            .majorVersion( majorVersion ) \
            .minorVersion( minorVersion ) \
            .patchVersion( patchVersion )
        self.__init_temp__()

    def tempAppUrl(self):
        if self.downloadUrl()[-1] == '/':
            return "%s%s/%d.%d/%s.tar.gz" % (self.downloadUrl(), self.binVer(), self.majorVersion(),self.minorVersion(), self.targetApp())
        else:
            return "%s/%s/%d.%d/%s.tar.gz" % (self.downloadUrl(), self.binVer(), self.majorVersion(),self.minorVersion(), self.targetApp())

    def tempTargetGzip(self):
        timestamp = self.timestamp()
        tempFolder = self.tempFolder()
        if tempFolder=="":
            return ""
        if self.isLinuxShell():
            return "%s/%s-%s.tar.gz" % (tempFolder, self.targetApp(), timestamp)
        elif self.isGitBash() or self.isCmd():
            return "%s\\%s-%s.tar.gz" % (tempFolder, self.targetApp(), timestamp)
        return "%s/%s-%s.tar.gz" % (tempFolder, self.targetApp(), timestamp)

    def tempAttachDecomp(self):
        tempFolder=self.tempFolder()
        if tempFolder=="":
            return ""
        if self.isCmd():
            fname="%s\\%s" % (tempFolder,self.targetApp())
        elif self.isGitBash():
            fname="%s/%s" % (tempFolder,self.targetApp())
        else:
            fname="%s/%s" % (tempFolder, self.targetApp())
        return fname

    def translateScript(self, source="", target="", useSudo=False):
        tempFolder=self.tempFolder()
        if tempFolder=="":
            return False
        result = False
        if self.pathexists(source):
            tempScript = "%s.tmp" % self.tempFile()
            if tempScript!=source:
                self.history_open_as_source(source, currentframe().f_lineno)
                file1 = self.open(source, 'r')
                self.history_open_as_target(tempScript, currentframe().f_lineno)
                file2 = self.open(tempScript,'w')
                if self.isCmd() or self.isGitBash():
                    for line in file1:
                        if line.startswith('##! '):
                            file2.write(line[4:])
                        elif not (line.startswith('from __future__') or line.startswith('#!') or line.startswith('# -*-')):
                            file2.write(line)
                else:
                    for line in file1:
                        if line.startswith('#!/bin/sh'):
                            file2.write('#!%s\n' % sys.executable)
                        else:
                            file2.write(line)
                file1.close()
                file2.close()
                if source.startswith(tempFolder):
                    self.history_remove_source(currentframe().f_lineno)
                    self.removeFile(source)
                self.history_copy_temp(currentframe().f_lineno)
                self.cp(tempScript, target, useSudo=useSudo)
                self.history_remove_temp(currentframe().f_lineno)
                self.removeFile(tempScript)
                if not self.is_window():
                    self.history_change_target_mode(currentframe().f_lineno)
                    result=self.chmod_x(target, useSudo=useSudo)
                else:
                    return True
        else:
            self.msg_download_not_found(target)
        return result

    def usage(self, para=None):
        if para is not None:
            if "|" in para:
                for subcmd in para.split("|"):
                    s = subcmd.strip()
                    if s !="":
                        self.subCmd(s)
            elif "," in para: 
                for subcmd in para.split(","):
                    s = subcmd.strip()
                    if s !="":
                        self.subCmd(s)
            return self
        p = '|'.join(self.subCmd())
        return "%s [%s]" % (self.appExec(), p)

class CyMasterCore(AppBase):

    CLASSNAME = "CyMasterCore"
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 33
    CHECKED=False

    @staticmethod
    def class_version():
        return f"{CyMasterCore.CLASSNAME} v{CyMasterCore.MAJOR_VERSION}.{CyMasterCore.MINOR_VERSION}.{CyMasterCore.PATCH_VERSION}"

    def check_dependencies(self):
        if self.CHECKED:
            return True
        try:
            import setuptools  # Check if requests is available
            self.CHECKED = True
        except ImportError:
            print("Error: The 'setuptools' module is not available. Please install it: pip3 install requests")
            return False
        return True

    def msg_local_already(self, title="SELF INSTALL"):
        self.infoMsg("Local installed already!", title)

    def msg_install_global(self):
        self.msg_install("Globally", self.appName())

    def msg_install_local(self):
        self.msg_install("Locally", self.appName())

    def msg_no_install_global(self, title="GLOBAL UNINSTALL"):
        self.infoMsg("You don't have any global installation.", title)

    def msg_no_installation(self, title="UNINSTALL"):
        self.infoMsg("You don't have any global or local installation.", title)

    def msg_uninstall_local(self, title="LOCAL UNINSTALL"):
        self.safeMsg("You have uninstalled successfully.", title)

    def msg_uninstall_global_failed(self, title="UNINSTALL FAILED"):
        self.criticalMsg("Failed to uninstall globally", title)

    def __init__(self, this = None):
        try:
            super().__init__(fromClass=self, this=this)
        except:
            super(CyMasterCore, self).__init__(fromClass=self, this=this)

        if not self.check_dependencies():
            sys.exit(1)
        self.networkCore = NetworkCore()
        self.subCmd(["build","build-all","clean","install-all"])
        Attr(self, 'configFile', '')
        Attr(self, 'projectPath', '')
        Attr(self, 'targetName', '')
        Attr(self, 'targetType', 'so')
        Attr(self, 'buildFolder', '')
        Attr(self, 'srcFolder', '')
        Attr(self, 'startDirectory', os.getcwd())
        self.transition('checkSystem','STARTED','SYS_CHECKED')
        self.transition('checkStdinOk', 'SYS_CHECKED', 'FROM_STDIN')
        self.transition('checkSystemFail', 'STARTED', 'SYS_FAILED')
        self.transition('prerequsiteLocalFail', 'ARGUMENTS_PARSED_LOCAL', 'PREREQUSITE_LOCAL_FAILED')
        self.transition('notInstalledLocal', 'FROM_APP', 'NOT_INSTALLED_LOCAL')
        self.transition('notInstalledGlobal', 'FROM_APP', 'NOT_INSTALLED_GLOBAL')
        self.transition('parseArgumentsNotInstalledLocal', 'NOT_INSTALLED_LOCAL','ARGUMENTS_PARSED_NOT_INSTALLED_LOCAL')
        self.transition('parseArgumentsNotInstalledGlobal', 'NOT_INSTALLED_GLOBAL','ARGUMENTS_PARSED_NOT_INSTALLED_GLOBAL')
        self.transition('prerequsiteNotInstalledGlobalFail', 'ARGUMENTS_PARSED_NOT_INSTALLED_GLOBAL','PREREQUSITE_GLOBAL_FAILED')
        self.transition('prerequsiteNotInstalledLocalFail', 'ARGUMENTS_PARSED_NOT_INSTALLED_LOCAL','PREREQUSITE_LOCAL_FAILED')
        self.transition('prerequsiteGlobalFail', 'ARGUMENTS_PARSED_GLOBAL','PREREQUSITE_GLOBAL_FAILED')
        self.transition('showInfoLocal', 'ARGUMENTS_PARSED_LOCAL', 'SHOW_INFO_DONE')
        self.transition('showInfoGlobal', 'ARGUMENTS_PARSED_GLOBAL', 'SHOW_INFO_DONE')
        self.transition('showInfoNotInstalledLocal', 'ARGUMENTS_PARSED_NOT_INSTALLED_LOCAL', 'SHOW_INFO_DONE')
        self.transition('showInfoNotInstalledGlobal', 'ARGUMENTS_PARSED_NOT_INSTALLED_GLOBAL', 'SHOW_INFO_DONE')
        self.transition('tempLocalFromAppFail', 'LOCAL_UPDATE_NEEDED', 'TEMP_LOCAL_FAILED')
        self.transition('tempGlobalFromAppFail', 'GLOBAL_UPDATE_NEEDED', 'TEMP_GLOBAL_FAILED')
        self.transition('tempGlobalNotInstalledFail', 'ARGUMENTS_PARSED_NOT_INSTALLED_GLOBAL', 'TEMP_GLOBAL_FAILED')
        self.transition('tempLocalNotInstalledFail', 'ARGUMENTS_PARSED_NOT_INSTALLED_LOCAL', 'TEMP_LOCAL_FAILED')
        self.transition('systemInfo', 'FROM_STDIN', 'INFO_SHOWN_FROM_STDIN')
        self.transition('stdinLocal', 'INFO_SHOWN_FROM_STDIN', 'STDIN_LOCAL')
        self.transition('stdinGlobal', 'INFO_SHOWN_FROM_STDIN', 'STDIN_GLOBAL')
        self.transition('hasTempLocalStdin',  'STDIN_LOCAL',  'TEMP_CHECKED_LOCAL_STDIN')
        self.transition('hasTempGlobalStdin',  'STDIN_GLOBAL',  'TEMP_CHECKED_GLOBAL_STDIN')
        self.transition('tempLocalStdinFail', 'STDIN_LOCAL', 'TEMP_LOCAL_STDIN_FAILED')
        self.transition('tempGlobalStdinFail', 'STDIN_GLOBAL', 'TEMP_GLOBAL_STDIN_FAILED')
        self.transition('downloadLocalFail', 'INSTALLER_DOWNLOADABLE_LOCAL', 'INSTALLER_DOWNLOAD_LOCAL_FAILED')
        self.transition('downloadGlobalFail', 'INSTALLER_DOWNLOADABLE_GLOBAL', 'INSTALLER_DOWNLOAD_GLOBAL_FAILED')
        self.transition('downloadLocalStdinFail', 'TEMP_CHECKED_LOCAL_STDIN', 'INSTALLER_DOWNLOAD_LOCAL_FAILED')
        self.transition('downloadGlobalStdinFail', 'TEMP_CHECKED_GLOBAL_STDIN', 'INSTALLER_DOWNLOAD_GLOBAL_FAILED')
        self.transition('downloadLocalStdin', 'TEMP_CHECKED_LOCAL_STDIN', 'INSTALLER_DOWNLOADED_LOCAL')
        self.transition('downloadGlobalStdin', 'TEMP_CHECKED_GLOBAL_STDIN', 'INSTALLER_DOWNLOADED_GLOBAL')
        self.transition('finishInstallerGlobal', 'INSTALLER_COPIED_GLOBAL', 'INSTALLER_GLOBAL_DONE')
        self.transition('appOk', 'SYS_CHECKED', 'FROM_APP')
        self.transition('fromAppLocal', 'FROM_APP', 'FROM_APP_LOCAL')
        self.transition('fromAppGlobal', 'FROM_APP', 'FROM_APP_GLOBAL')
        self.transition('parseArgumentsLocal', 'FROM_APP_LOCAL', 'ARGUMENTS_PARSED_LOCAL')
        self.transition('parseArgumentsGlobal', 'FROM_APP_GLOBAL', 'ARGUMENTS_PARSED_GLOBAL')
        self.transition('needLocalUpdate', 'ARGUMENTS_PARSED_LOCAL', 'LOCAL_UPDATE_NEEDED')
        self.transition('needGlobalUpdate', 'ARGUMENTS_PARSED_GLOBAL', 'GLOBAL_UPDATE_NEEDED')
        self.transition('hasTempLocalFromApp', 'LOCAL_UPDATE_NEEDED', 'TEMP_CHECKED_LOCAL')
        self.transition('hasTempNotInstalledGlobal', 'ARGUMENTS_PARSED_NOT_INSTALLED_GLOBAL', 'TEMP_CHECKED_GLOBAL')
        self.transition('hasTempNotInstalledLocal', 'ARGUMENTS_PARSED_NOT_INSTALLED_LOCAL', 'TEMP_CHECKED_LOCAL')
        self.transition('hasTempGlobalFromApp', 'GLOBAL_UPDATE_NEEDED', 'TEMP_CHECKED_GLOBAL')
        self.transition('installFromApp', 'TEMP_CHECKED_LOCAL', 'INSTALLER_DOWNLOADED_LOCAL')
        self.transition('otherCmdGlobal', 'ARGUMENTS_PARSED_GLOBAL', 'OTHER_CMD_GLOBAL_DONE')
        self.transition('otherCmdLocal', 'ARGUMENTS_PARSED_LOCAL', 'OTHER_CMD_LOCAL_DONE')
        self.transition('displayUsageGlobal', 'ARGUMENTS_PARSED_GLOBAL', 'DISPLAY_USAGE_DONE')
        self.transition('displayUsageLocal', 'ARGUMENTS_PARSED_LOCAL', 'DISPLAY_USAGE_DONE')
        self.transition('displayUsageNotInstalledGlobal', 'ARGUMENTS_PARSED_NOT_INSTALLED_GLOBAL', 'DISPLAY_USAGE_DONE')
        self.transition('displayUsageNotInstalledLocal', 'ARGUMENTS_PARSED_NOT_INSTALLED_LOCAL', 'DISPLAY_USAGE_DONE')
        self.transition('urlLocalOk', 'TEMP_CHECKED_LOCAL', 'INSTALLER_DOWNLOADABLE_LOCAL')
        self.transition('urlGlobalOk', 'TEMP_CHECKED_GLOBAL', 'INSTALLER_DOWNLOADABLE_GLOBAL')
        self.transition('downloadLocal', 'INSTALLER_DOWNLOADABLE_LOCAL', 'INSTALLER_DOWNLOADED_LOCAL')
        self.transition('downloadGlobal', 'INSTALLER_DOWNLOADABLE_GLOBAL', 'INSTALLER_DOWNLOADED_GLOBAL')
        self.transition('copyInstallerGlobal', 'INSTALLER_DOWNLOADED_GLOBAL', 'INSTALLER_COPIED_GLOBAL')
        self.transition('copySelfGlobal', 'ARGUMENTS_PARSED_NOT_INSTALLED_GLOBAL', 'INSTALLER_COPIED_GLOBAL')
        self.transition('finishAttachmentGlobal', 'ATTACHMENT_COPIED_GLOBAL', 'INSTALLER_GLOBAL_DONE')
        self.transition('parseArgumentFail', 'FROM_APP', 'NO_ARGUMENT_FAILED')
        self.transition('alreadyInstalledLocal', 'ARGUMENTS_PARSED_LOCAL', 'INSTALLED_ALREADY')
        self.transition('alreadyInstalledGlobal', 'ARGUMENTS_PARSED_GLOBAL', 'INSTALLED_ALREADY')
        self.transition('checkInstalledLocal', 'ARGUMENTS_PARSED_LOCAL', 'INSTALLED_LOCAL')
        self.transition('uninstallAttachmentLocal', 'INSTALLED_LOCAL', 'UNINSTALL_ATTACHMENT_LOCAL')
        self.transition('urlLocalFail', 'TEMP_CHECKED_LOCAL', 'URL_LOCAL_FAILED')
        self.transition('urlGlobalFail', 'TEMP_CHECKED_GLOBAL', 'URL_GLOBAL_FAILED')
        self.transition('copyInstallerGlobalFail', 'INSTALLER_DOWNLOADED_GLOBAL', 'INSTALLER_COPING_GLOBAL_FAILED')
        self.transition('copyInstallerLocalFail', 'INSTALLER_DOWNLOADED_LOCAL', 'INSTALLER_COPING_LOCAL_FAILED')
        self.transition('copyAttachmentGlobal', 'ATTACHMENT_DOWNLOADED_GLOBAL', 'ATTACHMENT_COPIED_GLOBAL')
        self.transition('downloadAttachmentGlobal', 'INSTALLER_COPIED_GLOBAL', 'ATTACHMENT_DOWNLOADED_GLOBAL')
        self.transition('otherCmdGlobalFail', 'ARGUMENTS_PARSED_GLOBAL', 'OTHER_CMD_FAILED')
        self.transition('otherCmdLocalFail', 'ARGUMENTS_PARSED_LOCAL', 'OTHER_CMD_FAILED')
        self.transition('uninstallAttachmentLocalFail', 'INSTALLED_LOCAL', 'UNINSTALL_ATTACHMENT_LOCAL_FAILED')
        self.transition('uninstallInstallerAttachmentLocalFail', 'UNINSTALL_ATTACHMENT_LOCAL', 'UNINSTALL_INSTALLER_FAILED')
        self.transition('uninstallInstallerAttachmentLocal', 'UNINSTALL_ATTACHMENT_LOCAL', 'UNINSTALL_LOCAL_DONE')
        self.transition('noLocalAttachment', 'INSTALLED_LOCAL', 'NO_LOCAL_ATTACHMENT')
        self.transition('uninstallInstallerLocal', 'NO_LOCAL_ATTACHMENT', 'UNINSTALL_LOCAL_DONE')
        self.transition('uninstallInstallerLocalFail', 'NO_LOCAL_ATTACHMENT', 'UNINSTALL_INSTALLER_LOCAL_FAILED')
        self.transition('downloadAttachmentGlobalFail', 'INSTALLER_COPIED_GLOBAL', 'ATTACHMENT_DOWNLOAD_GLOBAL_FAILED')
        self.transition('copyAttachmentGlobalFail', 'ATTACHMENT_DOWNLOADED_GLOBAL', 'ATTACHMENT_COPYING_GLOBAL_FAILED')
        self.transition('checkInstalledGlobal', 'ARGUMENTS_PARSED_GLOBAL', 'INSTALLED_GLOBAL')
        self.transition('globalUninstallFail', 'ARGUMENTS_PARSED_NOT_INSTALLED_GLOBAL', 'UNINSTALL_FAILED')
        self.transition('localUninstallFail', 'ARGUMENTS_PARSED_NOT_INSTALLED_LOCAL', 'UNINSTALL_FAILED')
        self.transition('uninstallAttachmentGlobalFail', 'INSTALLED_GLOBAL', 'UNINSTALL_ATTACHMENT_GLOBAL_FAILED')
        self.transition('copyInstallerLocal', 'INSTALLER_DOWNLOADED_LOCAL', 'INSTALLER_COPIED_LOCAL')
        self.transition('copySelfLocal', 'ARGUMENTS_PARSED_NOT_INSTALLED_LOCAL', 'INSTALLER_COPIED_LOCAL')
        self.transition('downloadAttachmentLocalFail', 'INSTALLER_COPIED_LOCAL', 'ATTACHMENT_DOWNLOAD_LOCAL_FAILED')
        self.transition('downloadAttachmentLocal', 'INSTALLER_COPIED_LOCAL', 'ATTACHMENT_DOWNLOADED_LOCAL')
        self.transition('copyAttachmentLocalFail', 'ATTACHMENT_DOWNLOADED_LOCAL', 'ATTACHMENT_COPYING_LOCAL_FAILED')
        self.transition('uninstallAttachmentGlobal', 'INSTALLED_GLOBAL', 'UNINSTALL_ATTACHMENT_GLOBAL')
        self.transition('noGlobalAttachment', 'INSTALLED_GLOBAL', 'NO_GLOBAL_ATTACHMENT')
        self.transition('uninstallInstallerGlobal', 'NO_GLOBAL_ATTACHMENT', 'UNINSTALL_GLOBAL_DONE')
        self.transition('uninstallInstallerAttachmentGlobal', 'UNINSTALL_ATTACHMENT_GLOBAL', 'UNINSTALL_GLOBAL_DONE')
        self.transition('uninstallInstallerAttachmentGlobalFail', 'UNINSTALL_ATTACHMENT_GLOBAL', 'UNINSTALL_INSTALLER_GLOBAL_FAILED')
        self.transition('uninstallInstallerGlobalFail', 'NO_GLOBAL_ATTACHMENT', 'UNINSTALL_INSTALLER_GLOBAL_FAILED')
        self.transition('uninstallInstallerAttachmentFail', 'NO_GLOBAL_ATTACHMENT', 'UNINSTALL_INSTALLER_FAILED')
        self.transition('finishInstallerLocal', 'INSTALLER_COPIED_LOCAL', 'INSTALLER_LOCAL_DONE')
        self.transition('finishAttachmentLocal', 'ATTACHMENT_COPIED_LOCAL', 'INSTALLER_LOCAL_DONE')
        self.transition('copyAttachmentLocal', 'ATTACHMENT_DOWNLOADED_LOCAL', 'ATTACHMENT_COPIED_LOCAL')
        self.after('checkSystem', self.afterCheckSystem)
        self.after('checkStdinOk', self.afterCheckStdinOk)
        self.after('checkSystemFail', self.debugInfo)
        self.after('prerequsiteLocalFail', self.debugInfo)
        self.after('notInstalledLocal', self.afterNotInstalledLocal)
        self.after('notInstalledGlobal', self.afterNotInstalledGlobal)
        self.after('parseArgumentsNotInstalledLocal', self.afterParseArgumentsNotInstalledLocal)
        self.after('parseArgumentsNotInstalledGlobal', self.afterParseArgumentsNotInstalledGlobal)
        self.after('prerequsiteNotInstalledGlobalFail', self.debugInfo)
        self.after('prerequsiteNotInstalledLocalFail', self.debugInfo)
        self.after('tempLocalFromAppFail', self.debugInfo)
        self.after('systemInfo', self.afterSystemInfo)
        self.after('stdinLocal', self.afterStdinLocal)
        self.after('stdinGlobal', self.afterStdinGlobal)
        self.after('tempLocalStdinFail', self.debugInfo)
        self.after('tempGlobalStdinFail', self.debugInfo)
        self.after('downloadLocalFail', self.debugInfo)
        self.after('downloadGlobalFail', self.debugInfo)
        self.after('downloadLocalStdinFail',self.debugInfo)
        self.after('downloadGlobalStdinFail',self.debugInfo)
        self.after('downloadLocalStdin', self.afterDownloadLocalStdin)
        self.after('downloadGlobalStdin', self.afterDownloadGlobalStdin)
        self.after('appOk', self.afterAppOk)
        self.after('fromAppLocal', self.afterFromAppLocal)
        self.after('fromAppGlobal',  self.afterFromAppGlobal)
        self.after('parseArgumentsLocal', self.afterParseArgumentsLocal)
        self.after('parseArgumentsGlobal', self.afterParseArgumentsGlobal)
        self.after('hasTempLocalFromApp', self.afterCheckTempLocal)
        self.after('hasTempNotInstalledGlobal', self.afterCheckTempGlobal)
        self.after('hasTempNotInstalledLocal', self.afterCheckTempLocal)
        self.after('displayUsageGlobal', self.afterDisplayUsageGlobal)
        self.after('displayUsageLocal', self.afterDisplayUsageLocal)
        self.after('displayUsageNotInstalledGlobal', self.afterDisplayUsageNotInstalledGlobal)
        self.after('displayUsageNotInstalledLocal', self.afterDisplayUsageNotInstalledLocal)
        self.after('hasTempLocalStdin', self.afterTempLocalStdin)
        self.after('hasTempGlobalStdin', self.afterTempGlobalStdin)
        self.after('urlLocalOk', self.afterUrlLocalOk)
        self.after('urlGlobalOk', self.afterUrlGlobalOk)
        self.after('downloadLocal', self.afterDownloadLocal)
        self.after('downloadGlobal', self.afterDownloadGlobal)
        self.after('copyInstallerGlobal', self.afterCopyInstallerGlobal)
        self.after('copySelfGlobal', self.finishInstallerGlobal)
        self.after('parseArgumentFail', self.afterParseArgumentFail)
        self.after('checkInstalledLocal', self.afterCheckInstalledLocal)
        self.after('uninstallAttachmentLocal', self.afterUninstallAttachmentLocal)
        self.after('urlLocalFail', self.debugInfo)
        self.after('urlGlobalFail', self.debugInfo)
        self.after('copyInstallerGlobalFail',  self.debugInfo)
        self.after('copyInstallerLocalFail', self.debugInfo)
        self.after('otherCmdLocalFail', self.debugInfo)
        self.after('otherCmdGlobalFail', self.debugInfo)
        self.after('uninstallAttachmentLocalFail', self.debugInfo)
        self.after('uninstallInstallerAttachmentLocalFail', self.debugInfo)
        self.after('uninstallInstallerAttachmentLocal', self.afterUninstallInstallerAttachmentLocal)
        self.after('noLocalAttachment', self.afterNoLocalAttachment)
        self.after('downloadAttachmentGlobalFail', self.debugInfo)
        self.after('copyAttachmentGlobalFail', self.debugInfo)
        self.after('checkInstalledGlobal', self.afterCheckInstalledGlobal)
        self.after('uninstallAttachmentGlobalFail', self.debugInfo)
        self.after('copyInstallerLocal', self.afterCopyInstallerLocal)
        self.after('copySelfLocal', self.finishInstallerLocal)
        self.after('downloadAttachmentLocalFail', self.debugInfo)
        self.after('copyAttachmentLocalFail', self.debugInfo)
        self.after('noGlobalAttachment', self.afterNoGlobalAttachment)
        self.after('uninstallInstallerAttachmentGlobal', self.afterUninstallInstallerAttachmentGlobal)
        self.after('uninstallInstallerAttachmentGlobalFail', self.debugInfo)
        self.after('uninstallInstallerGlobalFail', self.debugInfo)
        self.after('uninstallInstallerAttachmentFail',  self.debugInfo)
        self.on('alreadyInstalledGlobal', self.msg_global_already)
        self.on('alreadyInstalledLocal', self.msg_local_already)
        self.on('globalUninstallFail', self.msg_no_install_global)
        self.on('localUninstallFail', self.msg_no_installation)
        self.on('systemInfo', self.msg_system_check)
        self.on('showInfoLocal', self.msg_system_check)
        self.on('showInfoGlobal', self.msg_system_check)
        self.on('showInfoNotInstalledLocal', self.msg_system_check)
        self.on('showInfoNotInstalledGlobal', self.msg_system_check)
        self.on('alreadyInstalled', self.msg_latest_available)
        self.on('finishInstallerLocal', self.msg_install_local)
        self.on('finishInstallerGlobal', self.msg_install_global)
        self.on('uninstallInstallerLocal', self.msg_uninstall_local)
        self.on('uninstallInstallerGlobal', self.msg_uninstall_global)
        self.on('uninstallInstallerAttachmentLocal', self.msg_uninstall_local)
        self.on('uninstallInstallerAttachmentGlobal', self.msg_uninstall_global)
        self.before('checkSystem', self.beforeCheckSystem)
        self.before('downloadAttachmentLocal', self.beforeDownloadAttachmentLocal)
        self.before('downloadAttachmentGlobal', self.beforeDownloadAttachmentGlobal)
        self.before('downloadLocal', self.beforeDownloadLocal)
        self.before('downloadGlobal', self.beforeDownloadGlobal)
        self.before('downloadLocalStdin', self.beforeDownloadLocalStdin)
        self.before('downloadGlobalStdin', self.beforeDownloadGlobalStdin)
        self.before('copyInstallerLocal', self.beforeCopyInstallerLocal)
        self.before('copySelfLocal', self.beforeCopySelfLocal)
        self.before('copySelfGlobal', self.beforeCopySelfGlobal)
        self.before('copyInstallerGlobal', self.beforeCopyInstallerGlobal)
        self.before('uninstallAttachmentLocal',self.beforeUninstallAttachmentLocal)
        self.before('uninstallAttachmentGlobal',self.beforeUninstallAttachmentGlobal)
        self.state('STARTED')

    def debugInfo(self):
        self.cmd_history_print()

    def afterUninstallInstallerAttachmentLocal(self):
        if os.path.exists(self.localInstallPath()):
            self.history_remove_previous_local(currentframe().f_lineno)
            self.removeFile(self.localInstallPath())
        if os.path.exists(self.localInstallPath()):
            self.uninstallInstallerGlobalAttachmentFail()
        else:
            self.uninstallInstallerAttachmentLocal()     

    def afterUninstallInstallerAttachmentGlobal(self):
        if os.path.exists(self.globalInstallPath(0)):
            self.history_remove_previous_global(currentframe().f_lineno)
            self.sudoRemoveFile(self.globalInstallPath(0))
        if os.path.exists(self.globalInstallPath(1)):
            self.history_remove_previous_global(currentframe().f_lineno)
            self.sudoRemoveFile(self.globalInstallPath(1))
        if os.path.exists(self.globalInstallPath(0)) or os.path.exists(self.globalInstallPath(1)):
            self.uninstallInstallerAttachmentGlobalFail()
        else:
            self.uninstallInstallerAttachmentGlobal()  

    def afterUrlLocalOk(self):
        self.downloadLocal()

    def afterUrlGlobalOk(self):
        self.downloadGlobal()

    def afterNoGlobalAttachment(self):
        if os.path.exists(self.globalInstallPath(0)):
            self.history_remove_previous_global(currentframe().f_lineno)
            self.sudoRemoveFile(self.globalInstallPath(0))
        if os.path.exists(self.globalInstallPath(1)):
            self.history_remove_previous_global(currentframe().f_lineno)
            self.sudoRemoveFile(self.globalInstallPath(1))
        if os.path.exists(self.globalInstallPath(0)) or os.path.exists(self.globalInstallPath(1)):
            self.uninstallInstallerGlobalFail()
        else:
            self.uninstallInstallerGlobal()

    def afterNoLocalAttachment(self):
        if os.path.exists(self.localInstallPath()):
            self.history_remove_previous_local(currentframe().f_lineno)
            self.removeFile(self.localInstallPath())
        if os.path.exists(self.localInstallPath()):
            self.uninstallInstallerLocalFail()
        else:
            self.uninstallInstallerLocal()

    def afterAppOk(self):
        if self.parseArguments():
            if self.username()=='root':
                if self.isInstalledGlobal():
                    self.fromAppGlobal()
                else:
                    self.notInstalledGlobal()
            else:
                if self.isInstalledLocal():
                    self.fromAppLocal()
                elif self.isInstalledGlobal():
                    self.fromAppGlobal()
                else:
                    self.notInstalledLocal()

    def afterFromAppGlobal(self):
        self.parseArgumentsGlobal()

    def afterFromAppLocal(self):
        self.parseArgumentsLocal()

    def afterCheckInstalledGlobal(self):
        if self.targetApp() == '':
            self.noGlobalAttachment()
        else:
            self.uninstallAttachmentGlobal()

    def afterCheckInstalledLocal(self):
        if self.targetApp() == '':
            self.noLocalAttachment()
        else:
            self.uninstallAttachmentLocal()

    def afterStdinLocal(self):
        if self.allowSelfInstall():
            if self.tempFolder() == "":
                self.tempLocalStdinFail()
                return False
            else:
                self.hasTempLocalStdin()

    def afterStdinGlobal(self):
        if self.allowSelfInstall():
            if self.tempFolder() == "":
                self.tempGlobalStdinFail()
                return False
            else:
                self.hasTempGlobalStdin()

    def parseArguments(self):
        if len(sys.argv) > 1:
            self.cmd(sys.argv[1])
            for subCmd in self.subCmd():
                if subCmd == self.cmd():
                    return True
        self.parseArgumentFail()
        return False

    def afterDisplayUsageGlobal(self):
        self.msg_info(self.usage())

    def afterDisplayUsageNotInstalledGlobal(self):
        self.msg_info(self.usage())

    def afterDisplayUsageNotInstalledLocal(self):
        self.msg_info(self.usage())

    def afterDisplayUsageLocal(self):
        self.msg_info(self.usage())

    def afterParseArgumentFail(self):
        if self.allowDisplayInfo():
            self.msg_info(self.usage())

    def afterNotInstalledLocal(self):
        self.parseArgumentsNotInstalledLocal()

    def afterNotInstalledGlobal(self):
        self.parseArgumentsNotInstalledGlobal()

    def afterCheckSystem(self):
        if self.fromPipe():
            self.checkStdinOk()
        else:
            self.appOk()

    def afterUninstallAttachmentGlobal(self):
        self.uninstallInstallerAttachmentGlobal()

    def afterUninstallAttachmentLocal(self):
        self.uninstallInstallerAttachmentLocal()

    def afterSystemInfo(self):
        if self.username() == 'root':
            self.stdinGlobal()
        else:
            self.stdinLocal()

    def afterCheckStdinOk(self):
        self.systemInfo()

    def afterParseArgumentsLocal(self):
        if len(sys.argv) > 1:
            self.cmd(sys.argv[1])
            if self.cmd() == "install":
                if self.hasFunc("requisite"):
                    result = self.requisite()
                    if not result:
                        self.prerequsiteLocalFail()
                        return False
                if self.isInstalledLocal():
                    if self.need_update():
                        self.needLocalUpdate()
                    else:
                        self.alreadyInstalledLocal()
                elif self.isInstalledGlobal():
                    self.alreadyInstalledLocal()
            elif self.cmd() == "uninstall":
                if self.isInstalledLocal():
                    self.checkInstalledLocal()
                elif self.isInstalledGlobal():
                    self.checkInstalledGlobal()
            elif self.cmd() == "info":
                self.showInfoLocal()
            else:
                return self.extraCmd(isLocal=True)

    def build_process(self):
        if self.checkConfig():
            self.check_setup_py(version=3)
            if self.targetType() =='so':
                self.build_lib(version=3)
            else:
                self.build_binary(version=3)
        return True

    def buildAll(self):
        # Loop through the directory structure recursively
        for root, dirs, files in os.walk(self.startDirectory()):
            if self.signal() == 2:
                sys.exit(1)
            if 'cy-master.ini' in files:
                ini_path = os.path.join(root, 'cy-master.ini')
                try:
                    # Change to the directory containing the ini file
                    if root != self.startDirectory():
                        os.chdir(root)
                    # Use subprocess to call the shell command 'cat'
                    self.checkConfig(config_path=root)
                    self.check_setup_py(version=3, config_path=root)
                    if self.targetType() =='so':
                        self.build_lib(version=3, config_path=root)
                    else:
                        self.build_binary(version=3, config_path=root)
                except subprocess.CalledProcessError as e:
                    print(f"Error reading file {ini_path}: {e}")
                except Exception as e:
                    print(f"Could not read file {ini_path}: {e}")
                # Change back to the original directory
                if root != self.startDirectory():
                    os.chdir(self.startDirectory())
                if self.appName() in files:
                    self.safeMsg(f"Synchronize: {root}/{self.appName()}", "SCRIPT FOUND")
                    self.cmd_history(f"# ** Synchronize: {root}/{self.appName()} **", currentframe().f_lineno)  
                    self.cp(self.thisFile(), root)
        return True

    def sudoCopy(self, src, target):
        cmd = f"sudo cp {src} {target}"
        self.shell(cmd)

    def installAll(self):
        if not Sudoer.root_or_sudo():
            self.criticalMsg("You should be root or sudo to run this program", "SUDO REQUIRED")
            return False
        # Loop through the directory structure recursively
        for root, dirs, files in os.walk(self.startDirectory()):
            if self.signal() == 2:
                sys.exit(1)
            if 'cy-master.ini' in files:
                ini_path = os.path.join(root, 'cy-master.ini')
                try:
                    # Change to the directory containing the ini file
                    if root != self.startDirectory():
                        os.chdir(root)
                    # Use subprocess to call the shell command 'cat'
                    self.checkConfig(config_path=root)
                    self.check_setup_py(version=3, config_path=root)
                    if self.targetType() =='so':
                        lib_folder = '%s/%s/lib' % (root,self.buildFolder())
                        for r,d,lib_files in os.walk(lib_folder):
                            for libFile in lib_files:
                                if libFile.endswith('.so'):
                                    cy_string=libFile.split('.')[1]
                                    if cy_string.startswith('cpython-'):
                                        ver = cy_string.split('-')[1]
                                        vM = ver[0]
                                        vN = ver[1:]
                                        libSrc=os.path.join(r,libFile)
                                        libTrg=f'/usr/lib/python{vM}.{vN}/lib-dynload'
                                        if os.path.exists(libTrg):
                                            self.safeMsg(f"{libSrc} -> {libTrg}","COPY")
                                            self.sudoCopy(libSrc, libTrg)
                    else:

                        old_bin = '%s/%s/bin/%s' % (root,self.buildFolder(),self.targetName())
                        if self.pathexists(old_bin):
                            self.cmd_history(f"# ** Remove old binary file: {old_bin} **", currentframe().f_lineno)  
                            self.removeFile(old_bin)
                        bin_folder = '%s/%s/bin/%s' % (root,self.buildFolder(),self.binVer())
                        for r,d,lib_files in os.walk(bin_folder):
                            for binFile in lib_files:
                                binPath=os.path.join(r,binFile)
                                self.safeMsg(f"{binPath} -> /usr/local/bin","COPY")
                                self.sudoCopy(binPath, '/usr/local/bin')
                except subprocess.CalledProcessError as e:
                    print(f"Error reading file {ini_path}: {e}")
                except Exception as e:
                    print(f"Could not read file {ini_path}: {e}")
                # Change back to the original directory
                if root != self.startDirectory():
                    os.chdir(self.startDirectory())
                if self.appName() in files:
                    self.safeMsg(f"Synchronize: {root}/{self.appName()}", "SCRIPT FOUND")
                    self.cmd_history(f"# ** Synchronize: {root}/{self.appName()} **", currentframe().f_lineno)  
                    self.cp(self.thisFile(), root)
        return True

    def afterParseArgumentsGlobal(self):
        if len(sys.argv) > 1:
            self.cmd(sys.argv[1])
            if self.cmd() == "install":
                if self.hasFunc("requisite"):
                    result = self.requisite()
                    if not result:
                        self.prerequsiteGlobalFail()
                        return False
                if self.isInstalledGlobal():
                    if self.need_update():
                        self.needGlobalUpdate()
                    else:
                        self.alreadyInstalledGlobal()
                elif self.isInstalledLocal():
                    self.alreadyInstalledLocal()
            elif self.cmd() == "uninstall":
                if self.isInstalledLocal():
                    self.checkInstalledLocal()
                elif self.isInstalledGlobal():
                    self.checkInstalledGlobal()
            elif self.cmd() == "info":
                self.showInfoGlobal()
            else:
                return self.extraCmd(isLocal=False)

    def afterParseArgumentsNotInstalledLocal(self):
        if len(sys.argv) > 1:
            self.cmd(sys.argv[1])
            if self.cmd() == "install":
                if self.hasFunc("requisite"):
                    result = self.requisite()
                    if not result:
                        self.prerequsiteNotInstalledLocalFail()
                        return False
                if self.need_update():
                    if self.tempFolder() == "":
                        self.tempLocalNotInstalledFail()
                        return False
                    else:
                        self.hasTempNotInstalledLocal()
                else:
                    self.copySelfLocal()
            elif self.cmd() == "uninstall":
                if self.isInstalledLocal():
                    self.checkInstalledLocal()
                elif self.isInstalledGlobal():
                    self.checkInstalledGlobal()
                else:
                    self.localUninstallFail()
            elif self.cmd() == "info":
                self.showInfoNotInstalledLocal()
            else:
                return self.extraCmd(isLocal=True)

    def afterParseArgumentsNotInstalledGlobal(self):
        if len(sys.argv) > 1:
            self.cmd(sys.argv[1])
            if self.cmd() == "install":
                if self.hasFunc("requisite"):
                    result = self.requisite()
                    if not result:
                        self.prerequsiteNotInstalledGlobalFail()
                        return False
                if self.need_update():
                    if self.tempFolder() == "":
                        self.tempGlobalNotInstalledFail()
                        return False
                    else:
                        self.hasTempNotInstalledGlobal()
                else:
                    self.copySelfGlobal()
            elif self.cmd() == "uninstall":
                if self.isInstalledLocal():
                    self.checkInstalledLocal()
                elif self.isInstalledGlobal():
                    self.checkInstalledGlobal()
                else:
                    self.globalUninstallFail()
            elif self.cmd() == "info":
                self.showInfoNotInstalledGlobal()
            else:
                return self.extraCmd(isLocal=False)

    def extraCmd(self, isLocal=True):
        parsed = True
        if self.cmd()== "check-version": 
            if self.need_update():
                self.msg_latest_available()
            else:
                if isLocal:
                    self.msg_latest_local()
                else:
                    self.msg_latest_global()
            self.otherCmdGlobal()
        elif self.cmd() == 'usage':
            if isLocal: 
                self.displayUsageNotInstalledLocal()
            else:
                self.displayUsageNotInstalledGlobal()
        elif self.cmd() == 'clean':
            if self.checkConfig():
                self.clean_project()
        elif self.cmd() == 'build':
            self.build_process()
        elif self.cmd() == 'build-all':
            self.buildAll()
        elif self.cmd() == 'install-all':
            self.installAll()
        else:
            parsed = False
        if parsed:
            self.cmd_history_print()
            if isLocal: 
                self.otherCmdLocal()
            else:
                self.otherCmdGlobal()
        return False

    def afterCopyInstallerLocal(self):
        if self.targetApp() == '': 
            self.finishInstallerLocal()
        else:
            if self.curl_is_200(self.tempAppUrl()):
                self.downloadAttachmentLocal()
            else:
                self.downloadAttachmentLocalFail()
    
    def afterInstallRequisiteLocal(self):
        if self.hasFunc("requisite"):
            self.requisite()
        self.msg_install_app_local()

    def afterCopyInstallerGlobal(self):
        if self.targetApp() == '': 
            self.finishInstallerGlobal()
        else:
            if self.curl_is_200(self.tempAppUrl()):
                self.downloadAttachmentGlobal()
            else:
                self.downloadAttachmentGlobalFail()

    def afterInstallRequisiteGlobal(self):
        if self.hasFunc("requisite"):
            self.requisite()
        self.msg_install_app_global();

    def beforeUninstallAttachmentGlobal(self):
        display_once = False
        result = False
        if self.targetApp() != '':
            file1 = "%s/%s" % (self.globalFolder(0), self.targetApp())
            file2 = "%s/%s" % (self.globalFolder(1), self.targetApp())
            if os.path.exists(file1):
                self.history_remove_previous_global(currentframe().f_lineno)
                display_once = True
                self.sudoRemoveFile(file1)
                result = True
            if os.path.exists(file1):
                if not display_once:
                    self.history_remove_previous_global(currentframe().f_lineno)
                    display_once = True
                self.sudoRemoveFile(file2)
                result = True
            if not result:
                self.uninstallAttachmentGlobalFail()
        else:
            result = True
        return result

    def beforeUninstallAttachmentLocal(self):
        display_once = False
        result = False
        if self.targetApp() != '':
            file1 = "%s/%s" % (self.localInstallFolder(), self.targetApp())
            if os.path.exists(file1):
                self.history_remove_previous_local(currentframe().f_lineno)
                display_once = True
                self.removeFile(file1)
                result = True
            else:
                result = True
            if not result:
                self.uninstallAttachmentLocalFail()
        else:
            result = True
        return result

    def beforeCopyInstallerLocal(self):
        return self.copyFileLocal()

    def beforeCopySelfLocal(self):
        return self.copyFileLocal()

    def copyFileLocal(self):
        result = False
        this = self.thisFile()     # will be modified to tmp file in case from download
        if self.isCmd() or self.isGitBash():
            file = 'C:\\Users\\%s\\AppData\\Local\\Microsoft\\WindowsApps\\%s.bat' % (self.username(),self.appName())
        else:
            folder=self.localInstallFolder()
            self.mkdir(folder)
            file=self.localInstallPath()
        if self.pathexists(file):
            self.removeFile(file)
        if self.thisFile().endswith(".so"):
            self.history_copy_static_lib(this, currentframe().f_lineno)
            self.cp(self.thisFile(), self.localInstallFolder())
        else:
            result = self.translateScript(source=this, target=file, useSudo=False)
        self.chmod_x(file, useSudo=False)
        self.check_env()
        if self.pathexists(file):
            return True
        else:
            self.hasError()
            self.copyInstallerLocalFail()
            return False

    def beforeCopyInstallerGlobal(self):
        return self.beforeCopyFileGlobal()

    def beforeCopySelfGlobal(self):
        return self.beforeCopyFileGlobal()

    def beforeCopyFileGlobal(self):
        this = self.thisFile()     # will be modified to tmp file in case from download
        if self.isCmd() or self.isGitBash():
            return False
        if self.username()=='root':
            pass
        elif self.sudo_test():
            self.msg_sudo()
        else:
            if self.signal() != 2:
                self.msg_sudo_failed()
            self.hasError()
            return False
        self.removeGlobalInstaller()
        if self.thisFile().endswith(".so"):
            self.history_copy_static_lib(self.thisFile(), currentframe().f_lineno)
            if self.username() == 'root' :
                self.cp(self.thisFile(), self.globalInstallPath(1), useSudo=False)
                self.chmod_x(self.globalInstallPath(1), useSudo=False)
            else:
                self.cp(self.thisFile(), self.globalInstallPath(1), useSudo=True)
                self.chmod_x(self.globalInstallPath(1), useSudo=True)
        else:
            if self.username() == 'root' :
                result = self.translateScript(source=this, target=self.globalInstallPath(1),useSudo=False)
                self.chmod_x(self.globalInstallPath(1), useSudo=False)
            else:
                result = self.translateScript(source=this, target=self.globalInstallPath(1),useSudo=True)
                self.chmod_x(self.globalInstallPath(1), useSudo=True)
        if self.pathexists(self.globalInstallPath(1)):
            return True
        else:
            self.hasError()
            self.copyInstallerGlobalFail()
            return False

    def afterDownloadLocal(self):
        if self.username() != 'root':
            if self.allowInstallLocal():
                self.copyInstallerLocal()
            else:
                self.copyInstallerLocalFail()

    def afterDownloadGlobal(self):
        if self.username() == 'root':
            if self.allowInstallLocal():
                self.copyInstallerGlobal()
            else:
                self.copyInstallerGlobalFailed()

    def afterDownloadLocalStdin(self):
        self.copyInstallerLocal()

    def afterDownloadGlobalStdin(self):
        self.copyInstallerGlobal()

    def stateChanged(self, func=""):
        if ('STATE' in os.environ and os.environ['STATE'].lower() == 'show') \
            or ('state' in os.environ and os.environ['state'].lower() == 'show'):
            if func!="":
                func = " in %s" % func
            name = self._["transitionName"]
            fromState = self._["fromState"]
            toState = self._["toState"]
            self.infoMsg("Transition (%s%s) : [%s] -> [%s]" % ( name, func, fromState, toState), "STATE CHANGED")
        return self

    def afterCheckStdinOK(self):
        if self.allowSelfInstall():
            if self.tempFolder() == "":
                self.tempLocalStdinFail()
                return False
            else:
                self.hasTempLocalStdin()

    def afterCheckTempGlobal(self):
        self.history_curl_check(currentframe().f_lineno)
        url=self.downloadUrl()
        if self.curl_is_200(url):
            self.urlGlobalOk()
        else:
            self.urlGlobalFail()

    def afterCheckTempLocal(self):
        self.history_curl_check(currentframe().f_lineno)
        url=self.downloadUrl()
        if self.curl_is_200(url):
            self.urlLocalOk()
        else:
            self.urlLocalFail()

    def afterTempGlobalStdin(self):
        self.downloadGlobalStdin()

    def afterTempLocalStdin(self):
        self.downloadLocalStdin()

    def beforeDownloadAttachmentGlobal(self):
        if self.targetApp() == '':
            return True
        tempFolder = self.tempFolder()
        if tempFolder=="":
            self.downloadAttachmentGlobalFail()
            return False
        fname = self.tempTargetGzip()
        self.download_to_temp(url=self.tempAppUrl(), file=fname, verbal=False)
        if self.pathexists(fname):
            self.history_cd_decompress(currentframe().f_lineno)
            self.chdir(tempFolder, currentframe().f_lineno)
            if self.isCmd() or self.isGitBash():
                self.tar_extract( self.path_to_dos(fname).split('\\')[-1] )
            else:
                self.tar_extract(fname.split('/')[-1])
            self.history_remove_downloaded(currentframe().f_lineno)
            self.removeFile(fname)
            if self.isCmd() or self.isGitBash():
                this = "%s.exe" % self.tempAttachDecomp()
            else:
                this = self.tempAttachDecomp()
            if self.pathexists(this):
                self.this(this)
                if self.username() == 'root':
                    self.install_target_global(this, useSudo=False)
                else:
                    self.install_target_local(this)
                return True
            else:
                self.cmd_history_print(currentframe().f_lineno)
                self.msg_extraction_error(this)
                return False
        else:
            self.msg_download_error(self.tempTargetGzip())
            return False

    def beforeDownloadAttachmentLocal(self):
        if self.targetApp() == '':
            return True
        tempFolder = self.tempFolder()
        if tempFolder=="":
            self.downloadAttachmentLlobalFail()
            return False
        fname = self.tempTargetGzip()
        self.download_to_temp(url=self.tempAppUrl(), file=fname, verbal=False)
        if self.pathexists(fname):
            self.history_cd_decompress(currentframe().f_lineno)
            self.chdir(tempFolder, currentframe().f_lineno)
            if self.isCmd() or self.isGitBash():
                self.tar_extract( self.path_to_dos(fname).split('\\')[-1] )
            else:
                self.tar_extract(fname.split('/')[-1])
            self.history_remove_downloaded(currentframe().f_lineno)
            self.removeFile(fname)
            if self.isCmd() or self.isGitBash():
                this = "%s.exe" % self.tempAttachDecomp()
            else:
                this = self.tempAttachDecomp()
            if self.pathexists(this):
                self.this(this)
                if self.username() == 'root':
                    self.install_target_global(this, useSudo=False)
                else:
                    self.install_target_local(this)
                return True
            else:
                self.cmd_history_print(currentframe().f_lineno)
                self.msg_extraction_error(this)
                return False
        else:
            self.msg_download_error(self.tempTargetGzip())
            return False

    def display_fsm(self):
        self.prn("Transitions: %s" % self.events())
        self.prn("States: %s" % self.states())

    def beforeDownloadLocalStdin(self):
        if self.networkCore.check_online():
            self.history_curl_download(currentframe().f_lineno)
            self.curl_cmd(url=self.downloadUrl(), file=self.tempFile(), ignoreErr=False)
            if not self.pathexists(self.tempFile()):
                count=20
                # In gitbash, downloading time may be longer
                file = re.compile(r"*/").sub("",self.downloadUrl())
                self.msg_downloading(file)
                while count>0 and  not self.pathexists(self.tempFile()):
                    count = count - 1
                    time.sleep(1) # wait for curl download the file
            if self.pathexists(self.tempFile()):
                self.thisFile(self.tempFile())
                return True
            else:
                self.msg_timeout(self.tempFile())
        self.downloadLocalStdinFail()
        return False

    def beforeDownloadGlobalStdin(self):
        if self.networkCore.check_online():
            self.history_curl_download(currentframe().f_lineno)
            self.curl_cmd(url=self.downloadUrl(), file=self.tempFile(), ignoreErr=False)
            if not self.pathexists(self.tempFile()):
                count=20
                # In gitbash, downloading time may be longer
                file = re.compile(r".*/").sub("",self.downloadUrl())
                self.msg_downloading(file)
                while count>0 and  not self.pathexists(self.tempFile()):
                    count = count - 1
                    time.sleep(1) # wait for curl download the file
            if self.pathexists(self.tempFile()):
                self.thisFile(self.tempFile())
                return True
            else:
                self.msg_timeout(self.tempFile())
        self.downloadGlobalStdinFail()
        return False

    def beforeDownloadLocal(self):
        if self.networkCore.check_online():
            self.history_curl_download(currentframe().f_lineno)
            self.curl_cmd(url=self.downloadUrl(), file=self.tempFile(), ignoreErr=False)
            if not self.pathexists(self.tempFile()):
                count=20
                # In gitbash, downloading time may be longer
                file = re.compile(r"*/").sub("",self.downloadUrl())
                self.msg_downloading(file)
                while count>0 and  not self.pathexists(self.tempFile()):
                    count = count - 1
                    time.sleep(1) # wait for curl download the file
            if self.pathexists(self.tempFile()):
                self.thisFile(self.tempFile())
                return True
            else:
                self.msg_timeout(self.tempFile())
        self.downloadLocalFail()
        return False

    def beforeDownloadGlobal(self):
        if self.networkCore.check_online():
            self.history_curl_download(currentframe().f_lineno)
            self.curl_cmd(url=self.downloadUrl(), file=self.tempFile(), ignoreErr=False)
            if not self.pathexists(self.tempFile()):
                count=20
                # In gitbash, downloading time may be longer
                file = re.compile(r"*/").sub("",self.downloadUrl())
                self.msg_downloading(file)
                while count>0 and  not self.pathexists(self.tempFile()):
                    count = count - 1
                    time.sleep(1) # wait for curl download the file
            if self.pathexists(self.tempFile()):
                self.thisFile(self.tempFile())
                return True
            else:
                self.msg_timeout(self.tempFile())
        self.downloadGlobalFail()
        return False

    def clean_project(self):
        self.cmd_history("# ** clean folders **", currentframe().f_lineno)
        if self.buildFolder != '/':
            cmd=f"rm -rf {self.buildFolder()}"
            self.cmd_history(cmd)
            self.removeFolder(self.buildFolder())
        return True

    def check_setup_py(self, version=3, config_path=None):
        if config_path is None:
            config_path = self.projectPath()
        dir = '%s/%s' % (config_path, self.srcFolder())
        setup_py = '%s/setup.py' % (dir)
        self.cmd_history(f"# ** Prepare the cython setup file: {setup_py} **")
        self.cmd_history(f"cd {config_path}")
        self.chdir(config_path)
        if self.pathexists(setup_py):
            self.removeFile(setup_py)
        self.mkdir(dir)
        targetName=self.targetName()
        firstLine = ""
        if self.which_cmd('conda')!= '':
            firstLine = f"#!{sys.executable}"
        elif version==3:
            firstLine = f"#!{self.python3()}"
        elif version==2:
            firstLine = f"#!{self.python2()}"
        lines=[firstLine,
            'from setuptools import setup',
            'from Cython.Build import cythonize',
            '',
            'setup(',
            '  ext_modules=cythonize("%s/%s.pyx",compiler_directives={"language_level" : "%d"})' % (self.srcFolder(), targetName, version),
            ')',
            ''
        ]
        file = self.open(setup_py,'w')
        file.write('\n'.join(lines))
        file.close()
        self.chmod_x(setup_py)

    def ask_ini(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.fromPipe():
            return False
        while True:
            try:
                srcFolder = raw_input("Please state 'src'/'lib' folder (type 'exit' to exit): ").strip().lower()
            except:
                srcFolder = ""
            if srcFolder != "":
                break;
        if srcFolder == "exit":
            return False
        self.srcFolder(srcFolder)
        while True:
            try:
                buildFolder = raw_input("Please state 'build' folder (type 'exit' to exit): ").strip().lower()
            except:
                buildFolder = ""
            if buildFolder != "":
                break;
        if buildFolder == "exit":
            return False
        self.buildFolder(buildFolder)
        while True:
            try:
                targetName = raw_input("Please state 'target' file (exclude extenation, type 'exit' to exit): ").strip().lower()
            except:
                targetName = ""
            if targetName != "":
                break;
        if targetName == "exit":
            return False
        self.targetName(targetName)

        return True

    def ask_cython_version(self):
        if self.which_cmd('conda') == "":
            version = self.ask_choose_python_version()
            if version is None:
                exit()
            version = int(version)
            while  version<2 or version>3:
                version = self.ask_choose_python_version()
                if version is None: 
                    exit()
        else:
            version = int(self.pythonMajor())
            self.prn(f"  A. Using conda's python{version}!")
        return version

    def ask_choose_python_version(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.python2() == '' and self.python3() != '':
            self.prn("  A. Only python3 has been found!")
            return 3
        if self.python2() != '' and self.python3() == '':
            self.prn("  A. Only python2 has been found!")
            return 2
        if self.python2() == '' and self.python3() == '':
            self.critical("  You should either install python2 or python3!")
            return None
        if self.fromPipe():
            return None
        self.prn("  A. Please specify target:")
        return self.__ask_number__('    Which Python version 2 or 3 (type "exit" to exit)? ')

    def ask_choose_compile_mode(self):
        # fromPipe() usually involve from curl and don't have stdin
        if self.fromPipe():
            return None
        self.prn("  B. What do you want to:")
        self.prn("    1) compile binary")
        self.prn("    2) compile static library (.so) ")
        return self.__ask_number__('    Which option 1 or 2 (type "exit" to exit)? ')

    def build_binary(self, version=3, config_path=None):
        # make sure os.chdir(root) has been run before
        if config_path is None:
            config_path=os.getcwd()
        self.clean_project()
        cython = self.which_cmd("cython")
        c_folder = '%s/%s/c' % (config_path,self.buildFolder())
        target_c = f"{c_folder}/{self.targetName()}.c"
        if cython != "":
            if config_path is None:
                config_path = self.projectPath()
            if not self.pathexists(c_folder):
                self.safeMsg(f"Creating folder {c_folder}", "PREPARE")
                self.mkdir(c_folder)
            if not self.pathexists(c_folder):
                self.criticalMsg(f"Can't create folder {c_folder}", "PREPARE FAILED")
                sys.exit(1)
            old_bin = '%s/%s/bin/%s' % (config_path,self.buildFolder(),self.targetName())
            if self.pathexists(old_bin):
                self.cmd_history(f"# ** Remove old binary file: {old_bin} **", currentframe().f_lineno)
                self.removeFile(old_bin)
            bin_folder = '%s/%s/bin/%s' % (config_path,self.buildFolder(),self.binVer())
            if not self.pathexists(bin_folder):
                self.safeMsg(f"Creating folder {bin_folder}", "PREPARE")
                self.mkdir(bin_folder)
            if not self.pathexists(bin_folder):
                self.criticalMsg(f"Can't create folder {bin_folder}", "PREPARE FAILED")
                sys.exit(1)
            
            self.cmd_history("# ** Compile .pyx into .c file! **", currentframe().f_lineno)
            cmd = " ".join([cython,
                f"-{version}", 
                "-o", 
                target_c, 
                f"{self.srcFolder()}/{self.targetName()}.pyx", 
                "--embed"
            ])
            self.cmd_history(cmd)
            self.shell(cmd)
            #self.cmd_history(F"# ** Remove unused *.c in src folder! **")
            #rm_extra_c=f"rm -rf {self.srcFolder()}/*.c"
            #self.shell(rm_extra_c)
            gcc = self.which_cmd("gcc")
            if gcc != "":
                bin_file = f"{bin_folder}/{self.targetName()}" 
                self.cmd_history(F"# ** Compile into binary file! **")
                if version == 3:
                    cmd = " ".join([gcc,
                        target_c, 
                        f"-lpython{self.python3MainVersion()}",
                        f"{self.python3Include()}"
                        f"{self.python3Lib()}",
                        "-O2", 
                        "-Wl,-O1,-rpath=/usr/local/lib", 
                        "-o", 
                        bin_file
                    ])
                elif version == 2:
                    cmd = " ".join([gcc,
                        target_c, 
                        f"{self.python2Include()}"
                        f"{self.python2Lib()}",
                        "-O2", 
                        "-Wl,-O1,-rpath=/usr/local/lib", 
                        "-o", 
                        bin_file
                    ])
                self.cmd_history(cmd)
                self.shell(cmd)
            self.cmd_history(f"# ** clean c folder **", currentframe().f_lineno)
            cmd=f"rm -rf {c_folder}"
            self.cmd_history(cmd)
            self.removeFolder(c_folder)
            self.cmd_history(f"# ** clean temp folder **", currentframe().f_lineno)
            tmp_folder = f"{config_path}/{self.buildFolder()}/temp*"
            cmd=f"rm -rf {tmp_folder}"
            self.cmd_history(cmd)
            self.removeFolder(tmp_folder)
            self.cmd_history(f"# ** remove other c files **", currentframe().f_lineno)
            cmd=f"rm -rf {self.srcFolder()}/*.c"
            self.cmd_history(cmd)
            self.removeFile(f"{self.srcFolder()}/*.c")
        else:
            self.criticalMsg(f"Can't find cython", "COMPILATION FAILED")
            
    def python2MainVersion(self):
        cmd = "python2 --version"
        result, stdout= self.shell(cmd)
        if result:
            pyVerSplit=stdout.strip().split(" ")[1].split(".")
            return "%s.%s" % (pyVerSplit[0], pyVerSplit[1])
        return ""

    def python3MainVersion(self):
        cmd = "python3 --version"
        result, stdout= self.shell(cmd)
        if result:
            pyVerSplit=stdout.strip().split(" ")[1].split(".")
            return "%s.%s" % (pyVerSplit[0], pyVerSplit[1])
        else:
            return ""

    def python3Include(self):
        cmd = "python3-config --includes"
        result, stdout= self.shell(cmd)
        return stdout.strip()

    def python3Lib(self):
        cmd = "python3-config --libs"
        result, stdout= self.shell(cmd)
        return stdout.strip()

    def python2Include(self):
        cmd = "python-config --includes"
        result, stdout= self.shell(cmd)
        return stdout.strip()

    def python2Lib(self):
        cmd = "python-config --libs"
        result, stdout= self.shell(cmd)
        return stdout.strip()

    def build_lib(self, version=3, config_path=None):
        self.clean_project()
        self.cmd_history("# ** Parepare folder for compiling cython so **", currentframe().f_lineno)
        if config_path is None:
            config_path=os.getcwd()
        c_folder = '%s/%s/c' % (config_path, self.buildFolder())
        if not self.pathexists(c_folder):
            self.mkdir(c_folder)
        lib_folder = '%s/%s/lib' % (config_path,self.buildFolder())
        if not self.pathexists(lib_folder):
            self.mkdir(lib_folder)
        cython = self.which_cmd("cython")
        if cython != "":
            self.cmd_history("# ** Compile .pyx into .c file! **", currentframe().f_lineno)
            cmd = " ".join([cython,
                f"-{version}", 
                "-o", 
                f"{self.buildFolder()}/c/{self.targetName()}.c", 
                f"{self.srcFolder()}/{self.targetName()}.pyx", 
                "--embed"
            ])
            self.cmd_history(cmd)
            self.shell(cmd)
            self.cmd_history("# ** Compile into .so file! **", currentframe().f_lineno)
            if version==3:
                py = self.which_cmd("python3")
            else:
                py = self.which_cmd("python2")
            cmd=f"{self.srcFolder()}/setup.py build_ext --inplace"
            self.cmd_history(cmd)
            self.shell(cmd)
            self.cmd_history(f"# ** Move all the generated .so file to build/{self.pyMajor()}{self.pyMinor()}/lib **", currentframe().f_lineno)  
            cmd=f"mv *.so {lib_folder}/"
            self.shell(cmd)
            self.cmd_history("# ** clean temp folder **", currentframe().f_lineno)
            tmpFolder = f"{config_path}/lib.linux*"
            cmd=f"rm -rf {tmpFolder}"
            self.cmd_history(cmd)
            self.removeFolder(tmpFolder)
            self.cmd_history(f"# ** clean c folder **", currentframe().f_lineno)
            cmd=f"rm -rf {c_folder}"
            self.cmd_history(cmd)
            self.removeFolder(c_folder)
            c_folder

            self.safeMsg(f"Library: {self.targetName()}.{self.cythonString()}.so built", "BUILD")

    def checkConfig(self, display_list=False, config_path='.' , ini_name='cy-master.ini'):
        self.findConfig(config_path=config_path, ini_name=ini_name)
        if self.configFile() != '':
            self.srcFolder('')
            self.buildFolder('')
            self.targetName('')
            self.targetType('')
            try:
                config = configparser.ConfigParser()
                config.read( self.configFile() )
                if not config.has_section("project"):
                    self.criticalMsg(f"Configuration: {self.configFile()}\nSection `project` not found in cy-master.ini!", "CONFIG ERROR")
                    return False
                self.srcFolder(config.get("project", "srcFolder"))
                self.buildFolder(config.get("project", "buildFolder"))
                self.targetName(config.get("project", "targetName"))
                self.targetType(config.get("project", "targetType"))
            except:
                pass
            if self.srcFolder() != '' and self.buildFolder() != '' and self.targetName() != '':
                self.infoMsg(f"Project: {self.targetName()}\n  Configuation file: '%s' !" % self.configFile(), "CONFIG FOUND")
                return True
            else:
                self.criticalMsg(
                    f"Configuration: {self.configFile()}\n  The format of cy-master.ini is incorrect!  srcFolder:{self.srcFolder()} buildFolder:{self.buildFolder()}, targetName:{self.targetName()}", 
                    "CONFIG ERROR"
                )

        else:
            self.criticalMsg(f"Cannot find config file: {ini_name}!", "CONFIG ERROR")
            if self.ask_create_ini():
                if self.ask_ini():
                    config = configparser.ConfigParser()
                    config['project'] = {}
                    config['project']['srcFolder'] = self.srcFolder()
                    config['project']['buildFolder'] = self.buildFolder()
                    config['project']['targetName'] = self.targetName()
                    with open('cy-master.ini', 'w') as configfile:
                        config.write(configfile)
                    self.projectPath( os.getcwd() )
                    return True
        return False

    def requisite(self):
        result1 = self.install_musl_dev()
        result2 = self.install_gcc()

        result3 = self.install_pip()
        self.history_check_exists("cython", currentframe().f_lineno)
        cython = self.which_cmd('cython')
        if cython == '':
            result4 = self.install_python_package('cython')
        else:
            self.cmd_history(f"ls {cython}")
            self.history_package_exists("cython", currentframe().f_lineno)
            result4 = True
        result5 = self.install_python_dev()
        return (result1 or result2) and result3

if __name__ == "__main__":

    appname = 'CyMaster'
    MAJOR_VERSION = 1
    MINOR_VERSION = 0
    PATCH_VERSION = 24

    # Create logger instance
    logger = ChronicleLogger(logname=appname)
    appname=logger.logName()    
    basedir=logger.baseDir()
    if logger.isDebug():
        logger.log_message(f"{appname} v{MAJOR_VERSION}.{MINOR_VERSION}.{PATCH_VERSION} ({__file__}) with following:", component="main")
        logger.log_message(f">> {AppBase.class_version()}", component="main")
        logger.log_message(f">> {AppPara.class_version()}", component="main")
        logger.log_message(f">> {CheckSystem.class_version()}", component="main")
        logger.log_message(f">> {ChronicleLogger.class_version()}", component="main")
        logger.log_message(f">> {CmdHistory.class_version()}", component="main")
        logger.log_message(f">> {Curl.class_version()}", component="main")
        logger.log_message(f">> {CyMasterCore.class_version()}", component="main")
        logger.log_message(f">> {InstallPing.class_version()}", component="main")
        logger.log_message(f">> {NetworkCore.class_version()}", component="main")
        logger.log_message(f">> {PyCheck.class_version()}", component="main")
        logger.log_message(f">> {Shell.class_version()}", component="main")
        logger.log_message(f">> {ShellProfile.class_version()}", component="main")
        logger.log_message(f">> {Sudoer.class_version()}", component="main")
        logger.log_message(f">> {Temp.class_version()}", component="main")

    app = CyMasterCore(__file__)
    app.allowInstallLocal(True)
    app.setInstallation(appName=appname,author='Cloudgen Wong',homepage="https://github.com/cloudgen/cy-master",downloadUrl="https://dl.leolio.page/cy-master",lastUpdate='2025-09-02',majorVersion=1,minorVersion=0,patchVersion=24)
    app.checkSystem()
